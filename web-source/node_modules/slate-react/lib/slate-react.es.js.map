{"version":3,"file":"slate-react.es.js","sources":["../src/constants/event-handlers.js","../src/constants/plugin-props.js","../src/utils/offset-key.js","../src/components/leaf.js","../src/components/text.js","../src/components/void.js","../src/utils/get-children-decorations.js","../src/components/node.js","../src/utils/find-dom-node.js","../src/utils/find-dom-point.js","../src/utils/find-dom-range.js","../src/utils/find-point.js","../src/utils/find-range.js","../src/utils/scroll-to-selection.js","../src/utils/remove-all-ranges.js","../src/components/content.js","../src/constants/transfer-types.js","../src/utils/clone-fragment.js","../src/utils/find-node.js","../src/utils/get-event-range.js","../src/utils/get-event-transfer.js","../src/utils/set-event-transfer.js","../src/plugins/after.js","../src/plugins/before.js","../src/utils/noop.js","../src/components/editor.js","../src/index.js"],"sourcesContent":["/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst EVENT_HANDLERS = [\n  'onBeforeInput',\n  'onBlur',\n  'onClick',\n  'onContextMenu',\n  'onCompositionEnd',\n  'onCompositionStart',\n  'onCopy',\n  'onCut',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n  'onInput',\n  'onFocus',\n  'onKeyDown',\n  'onKeyUp',\n  'onPaste',\n  'onSelect',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default EVENT_HANDLERS\n","import EVENT_HANDLERS from './event-handlers'\n\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nconst PLUGIN_PROPS = [\n  ...EVENT_HANDLERS,\n  'decorateNode',\n  'onChange',\n  'renderEditor',\n  'renderMark',\n  'renderNode',\n  'renderPlaceholder',\n  'renderPortal',\n  'schema',\n  'validateNode',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default PLUGIN_PROPS\n","/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nconst PARSER = /^([\\w-]+)(?::(\\d+))?$/\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  const matches = PARSER.exec(string)\n\n  if (!matches) {\n    throw new Error(`Invalid offset key string \"${string}\".`)\n  }\n\n  const [original, key, index] = matches // eslint-disable-line no-unused-vars\n  return {\n    key,\n    index: parseInt(index, 10),\n  }\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return `${object.key}:${object.index}`\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  parse,\n  stringify,\n}\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport SlateTypes from 'slate-prop-types'\n\nimport OffsetKey from '../utils/offset-key'\n\n/**\n * Debugger.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:leaves')\n\n/**\n * Leaf.\n *\n * @type {Component}\n */\n\nclass Leaf extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block.isRequired,\n    editor: Types.object.isRequired,\n    index: Types.number.isRequired,\n    leaves: SlateTypes.leaves.isRequired,\n    marks: SlateTypes.marks.isRequired,\n    node: SlateTypes.node.isRequired,\n    offset: Types.number.isRequired,\n    parent: SlateTypes.node.isRequired,\n    text: Types.string.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    debug(message, `${this.props.node.key}-${this.props.index}`, ...args)\n  }\n\n  /**\n   * Should component update?\n   *\n   * @param {Object} props\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(props) {\n    // If any of the regular properties have changed, re-render.\n    if (\n      props.index != this.props.index ||\n      props.marks != this.props.marks ||\n      props.text != this.props.text ||\n      props.parent != this.props.parent\n    ) {\n      return true\n    }\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render the leaf.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n\n    const { node, index } = this.props\n    const offsetKey = OffsetKey.stringify({\n      key: node.key,\n      index,\n    })\n\n    return <span data-offset-key={offsetKey}>{this.renderMarks()}</span>\n  }\n\n  /**\n   * Render all of the leaf's mark components.\n   *\n   * @return {Element}\n   */\n\n  renderMarks() {\n    const { marks, node, offset, text, editor } = this.props\n    const { stack } = editor\n    const leaf = this.renderText()\n    const attributes = {\n      'data-slate-leaf': true,\n    }\n\n    return marks.reduce((children, mark) => {\n      const props = {\n        editor,\n        mark,\n        marks,\n        node,\n        offset,\n        text,\n        children,\n        attributes,\n      }\n      const element = stack.find('renderMark', props)\n      return element || children\n    }, leaf)\n  }\n\n  /**\n   * Render the text content of the leaf, accounting for browsers.\n   *\n   * @return {Element}\n   */\n\n  renderText() {\n    const { block, node, editor, parent, text, index, leaves } = this.props\n    const { value } = editor\n    const { schema } = value\n\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    if (schema.isVoid(parent)) {\n      return <span data-slate-zero-width=\"z\">{'\\uFEFF'}</span>\n    }\n\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    if (\n      text === '' &&\n      parent.object === 'block' &&\n      parent.text === '' &&\n      parent.nodes.last() === node\n    ) {\n      return <span data-slate-zero-width=\"n\">{'\\uFEFF'}</span>\n    }\n\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    if (text === '') {\n      return <span data-slate-zero-width=\"z\">{'\\uFEFF'}</span>\n    }\n\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    const lastText = block.getLastText()\n    const lastChar = text.charAt(text.length - 1)\n    const isLastText = node === lastText\n    const isLastLeaf = index === leaves.size - 1\n    if (isLastText && isLastLeaf && lastChar === '\\n') return `${text}\\n`\n\n    // Otherwise, just return the text.\n    return text\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Leaf\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport { PathUtils } from 'slate'\n\nimport Leaf from './leaf'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Text.\n *\n * @type {Component}\n */\n\nclass Text extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    style: Types.object,\n  }\n\n  /**\n   * Default prop types.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: null,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key } = node\n    debug(message, `${key} (text)`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate = nextProps => {\n    const { props } = this\n    const n = nextProps\n    const p = props\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node != p.node) return true\n\n    // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    if (n.parent.object == 'block') {\n      const pLast = p.parent.nodes.last()\n      const nLast = n.parent.nodes.last()\n      if (p.node == pLast && n.node != nLast) return true\n    }\n\n    // Re-render if the current decorations have changed.\n    if (!n.decorations.equals(p.decorations)) return true\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n\n    const { decorations, editor, node, style } = this.props\n    const { value } = editor\n    const { document } = value\n    const { key } = node\n\n    const decs = decorations.filter(d => {\n      const { start, end } = d\n\n      // If either of the decoration's keys match, include it.\n      if (start.key === key || end.key === key) return true\n\n      // Otherwise, if the decoration is in a single node, it's not ours.\n      if (start.key === end.key) return false\n\n      // If the node's path is before the start path, ignore it.\n      const path = document.assertPath(key)\n      if (PathUtils.compare(path, start.path) === -1) return false\n\n      // If the node's path is after the end path, ignore it.\n      if (PathUtils.compare(path, end.path) === 1) return false\n\n      // Otherwise, include it.\n      return true\n    })\n\n    // PERF: Take advantage of cache by avoiding arguments\n    const leaves = decs.size === 0 ? node.getLeaves() : node.getLeaves(decs)\n    let offset = 0\n\n    const children = leaves.map((leaf, i) => {\n      const child = this.renderLeaf(leaves, leaf, i, offset)\n      offset += leaf.text.length\n      return child\n    })\n\n    return (\n      <span data-key={key} style={style}>\n        {children}\n      </span>\n    )\n  }\n\n  /**\n   * Render a single leaf given a `leaf` and `offset`.\n   *\n   * @param {List<Leaf>} leaves\n   * @param {Leaf} leaf\n   * @param {Number} index\n   * @param {Number} offset\n   * @return {Element} leaf\n   */\n\n  renderLeaf = (leaves, leaf, index, offset) => {\n    const { block, node, parent, editor } = this.props\n    const { text, marks } = leaf\n\n    return (\n      <Leaf\n        key={`${node.key}-${index}`}\n        block={block}\n        editor={editor}\n        index={index}\n        marks={marks}\n        node={node}\n        offset={offset}\n        parent={parent}\n        leaves={leaves}\n        text={text}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Text\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\nimport Text from './text'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:void')\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nclass Void extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    children: Types.any.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    const id = `${key} (${type})`\n    debug(message, `${id}`, ...args)\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props } = this\n    const { children, node, readOnly } = props\n    const Tag = node.object == 'block' ? 'div' : 'span'\n    const style = {\n      height: '0',\n      color: 'transparent',\n      outline: 'none',\n      position: 'absolute',\n    }\n\n    const spacer = (\n      <Tag data-slate-spacer style={style}>\n        {this.renderText()}\n      </Tag>\n    )\n\n    const content = (\n      <Tag contentEditable={readOnly ? null : false}>{children}</Tag>\n    )\n\n    this.debug('render', { props })\n\n    return (\n      <Tag\n        data-slate-void\n        data-key={node.key}\n        contentEditable={readOnly || node.object == 'block' ? null : false}\n      >\n        {readOnly ? null : spacer}\n        {content}\n      </Tag>\n    )\n  }\n\n  /**\n   * Render the void node's text node, which will catch the cursor when it the\n   * void node is navigated to with the arrow keys.\n   *\n   * Having this text node there means the browser continues to manage the\n   * selection natively, so it keeps track of the right offset when moving\n   * across the block.\n   *\n   * @return {Element}\n   */\n\n  renderText = () => {\n    const { block, decorations, node, readOnly, editor } = this.props\n    const child = node.getFirstText()\n    return (\n      <Text\n        block={node.object == 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Void\n","import { Set } from 'immutable'\n\n/**\n * Split the decorations in lists of relevant decorations for each child.\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<List<Decoration>>}\n */\n\nfunction getChildrenDecorations(node, decorations) {\n  const activeDecorations = Set().asMutable()\n  const childrenDecorations = []\n\n  orderChildDecorations(node, decorations).forEach(item => {\n    if (item.isRangeStart) {\n      // Item is a decoration start\n      activeDecorations.add(item.decoration)\n    } else if (item.isRangeEnd) {\n      // item is a decoration end\n      activeDecorations.remove(item.decoration)\n    } else {\n      // Item is a child node\n      childrenDecorations.push(activeDecorations.toList())\n    }\n  })\n\n  return childrenDecorations\n}\n\n/**\n * Orders the children of provided node and its decoration endpoints (start, end)\n * so that decorations can be passed only to relevant children (see use in Node.render())\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<Item>}\n *\n * where type Item =\n * {\n *   child: Node,\n *   // Index of the child in its parent\n *   index: number\n * }\n * or {\n *   // True if this represents the start of the given decoration\n *   isRangeStart: boolean,\n *   // True if this represents the end of the given decoration\n *   isRangeEnd: boolean,\n *   decoration: Range\n * }\n */\n\nfunction orderChildDecorations(node, decorations) {\n  if (decorations.isEmpty()) {\n    return node.nodes.toArray().map((child, index) => ({\n      child,\n      index,\n    }))\n  }\n\n  // Map each key to its global order\n  const keyOrders = { [node.key]: 0 }\n  let globalOrder = 1\n\n  node.forEachDescendant(child => {\n    keyOrders[child.key] = globalOrder\n    globalOrder = globalOrder + 1\n  })\n\n  const childNodes = node.nodes.toArray()\n\n  const endPoints = childNodes.map((child, index) => ({\n    child,\n    index,\n    order: keyOrders[child.key],\n  }))\n\n  decorations.forEach(decoration => {\n    // Range start.\n    // A rangeStart should be before the child containing its startKey, in order\n    // to consider it active before going down the child.\n    const startKeyOrder = keyOrders[decoration.start.key]\n    const containingChildOrder =\n      startKeyOrder === undefined\n        ? 0\n        : getContainingChildOrder(childNodes, keyOrders, startKeyOrder)\n\n    endPoints.push({\n      isRangeStart: true,\n      order: containingChildOrder - 0.5,\n      decoration,\n    })\n\n    // Range end.\n    const endKeyOrder = (keyOrders[decoration.end.key] || globalOrder) + 0.5\n\n    endPoints.push({\n      isRangeEnd: true,\n      order: endKeyOrder,\n      decoration,\n    })\n  })\n\n  return endPoints.sort((a, b) => (a.order > b.order ? 1 : -1))\n}\n\n/*\n * Returns the key order of the child right before the given order.\n */\n\nfunction getContainingChildOrder(children, keyOrders, order) {\n  // Find the first child that is after the given key\n  const nextChildIndex = children.findIndex(\n    child => order < keyOrders[child.key]\n  )\n\n  if (nextChildIndex <= 0) {\n    return 0\n  }\n\n  const containingChild = children[nextChildIndex - 1]\n  return keyOrders[containingChild.key]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getChildrenDecorations\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport warning from 'slate-dev-warning'\nimport Types from 'prop-types'\n\nimport Void from './void'\nimport Text from './text'\nimport getChildrenDecorations from '../utils/get-children-decorations'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nclass Node extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    isFocused: Types.bool.isRequired,\n    isSelected: Types.bool.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    debug(message, `${key} (${type})`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(nextProps) {\n    const { props } = this\n    const { stack } = props.editor\n    const shouldUpdate = stack.find(\n      'shouldNodeComponentUpdate',\n      props,\n      nextProps\n    )\n    const n = nextProps\n    const p = props\n\n    // If the `Component` has a custom logic to determine whether the component\n    // needs to be updated or not, return true if it returns true. If it returns\n    // false, we need to ignore it, because it shouldn't be allowed it.\n    if (shouldUpdate != null) {\n      if (shouldUpdate) {\n        return true\n      }\n\n      warning(\n        shouldUpdate !== false,\n        \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\"\n      )\n    }\n\n    // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n    if (n.readOnly != p.readOnly) return true\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node != p.node) return true\n\n    // If the selection value of the node or of some of its children has changed,\n    // re-render in case there is any user-land logic depends on it to render.\n    // if the node is selected update it, even if it was already selected: the\n    // selection value of some of its children could have been changed and they\n    // need to be rendered again.\n    if (n.isSelected || p.isSelected) return true\n    if (n.isFocused || p.isFocused) return true\n\n    // If the decorations have changed, update.\n    if (!n.decorations.equals(p.decorations)) return true\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n    const {\n      editor,\n      isSelected,\n      isFocused,\n      node,\n      decorations,\n      parent,\n      readOnly,\n    } = this.props\n    const { value } = editor\n    const { selection, schema } = value\n    const { stack } = editor\n    const indexes = node.getSelectionIndexes(selection, isSelected)\n    const decs = decorations.concat(node.getDecorations(stack))\n    const childrenDecorations = getChildrenDecorations(node, decs)\n\n    let children = []\n\n    node.nodes.forEach((child, i) => {\n      const isChildSelected = !!indexes && indexes.start <= i && i < indexes.end\n\n      children.push(\n        this.renderNode(child, isChildSelected, childrenDecorations[i])\n      )\n    })\n\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    const attributes = { 'data-key': node.key }\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.object == 'block' && node.nodes.first().object != 'block') {\n      const direction = node.getTextDirection()\n      if (direction == 'rtl') attributes.dir = 'rtl'\n    }\n\n    const props = {\n      key: node.key,\n      editor,\n      isFocused,\n      isSelected,\n      node,\n      parent,\n      readOnly,\n    }\n\n    let placeholder = stack.find('renderPlaceholder', props)\n\n    if (placeholder) {\n      placeholder = React.cloneElement(placeholder, {\n        key: `${node.key}-placeholder`,\n      })\n\n      children = [placeholder, ...children]\n    }\n\n    const element = stack.find('renderNode', {\n      ...props,\n      attributes,\n      children,\n    })\n\n    return schema.isVoid(node) ? (\n      <Void {...this.props}>{element}</Void>\n    ) : (\n      element\n    )\n  }\n\n  /**\n   * Render a `child` node.\n   *\n   * @param {Node} child\n   * @param {Boolean} isSelected\n   * @param {Array<Decoration>} decorations\n   * @return {Element}\n   */\n\n  renderNode = (child, isSelected, decorations) => {\n    const { block, editor, node, readOnly, isFocused } = this.props\n    const Component = child.object == 'text' ? Text : Node\n\n    return (\n      <Component\n        block={node.object == 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        isSelected={isSelected}\n        isFocused={isFocused && isSelected}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Node\n","import { Node } from 'slate'\n\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key, win = window) {\n  if (Node.isNode(key)) {\n    key = key.key\n  }\n\n  const el = win.document.querySelector(`[data-key=\"${key}\"]`)\n\n  if (!el) {\n    throw new Error(\n      `Unable to find a DOM node for \"${key}\". This is often because of forgetting to add \\`props.attributes\\` to a custom component.`\n    )\n  }\n\n  return el\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMNode\n","import findDOMNode from './find-dom-node'\n\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point, win = window) {\n  const el = findDOMNode(point.key, win)\n  let start = 0\n  let n\n\n  // COMPAT: In IE, this method's arguments are not optional, so we have to\n  // pass in all four even though the last two are defaults. (2017/10/25)\n  const iterator = win.document.createNodeIterator(\n    el,\n    NodeFilter.SHOW_TEXT,\n    () => NodeFilter.FILTER_ACCEPT,\n    false\n  )\n\n  while ((n = iterator.nextNode())) {\n    const { length } = n.textContent\n    const end = start + length\n\n    if (point.offset <= end) {\n      const o = point.offset - start\n      return { node: n, offset: o >= 0 ? o : 0 }\n    }\n\n    start = end\n  }\n\n  return null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMPoint\n","import findDOMPoint from './find-dom-point'\n\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMRange(range, win = window) {\n  const { anchor, focus, isBackward, isCollapsed } = range\n  const domAnchor = findDOMPoint(anchor, win)\n  const domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win)\n\n  if (!domAnchor || !domFocus) return null\n\n  const r = win.document.createRange()\n  const start = isBackward ? domFocus : domAnchor\n  const end = isBackward ? domAnchor : domFocus\n  r.setStart(start.node, start.offset)\n  r.setEnd(end.node, end.offset)\n  return r\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMRange\n","import getWindow from 'get-window'\n\nimport OffsetKey from './offset-key'\n\n/**\n * Constants.\n *\n * @type {String}\n */\n\nexport const ZERO_WIDTH_ATTRIBUTE = 'data-slate-zero-width'\nexport const ZERO_WIDTH_SELECTOR = `[${ZERO_WIDTH_ATTRIBUTE}]`\nconst OFFSET_KEY_ATTRIBUTE = 'data-offset-key'\nconst RANGE_SELECTOR = `[${OFFSET_KEY_ATTRIBUTE}]`\nconst TEXT_SELECTOR = `[data-key]`\nconst VOID_SELECTOR = '[data-slate-void]'\n\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Value} value\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, value) {\n  const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n    nativeNode,\n    nativeOffset\n  )\n\n  const window = getWindow(nativeNode)\n  const { parentNode } = nearestNode\n  let rangeNode = parentNode.closest(RANGE_SELECTOR)\n  let offset\n  let node\n\n  // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n  if (rangeNode) {\n    const range = window.document.createRange()\n    const textNode = rangeNode.closest(TEXT_SELECTOR)\n    range.setStart(textNode, 0)\n    range.setEnd(nearestNode, nearestOffset)\n    node = textNode\n    offset = range.toString().length\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    const voidNode = parentNode.closest(VOID_SELECTOR)\n    if (!voidNode) return null\n    rangeNode = voidNode.querySelector(RANGE_SELECTOR)\n    if (!rangeNode) return null\n    node = rangeNode\n    offset = node.textContent.length\n  }\n\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n  if (\n    offset == node.textContent.length &&\n    parentNode.hasAttribute(ZERO_WIDTH_ATTRIBUTE)\n  ) {\n    offset--\n  }\n\n  // Get the string value of the offset key attribute.\n  const offsetKey = rangeNode.getAttribute(OFFSET_KEY_ATTRIBUTE)\n  if (!offsetKey) return null\n\n  const { key } = OffsetKey.parse(offsetKey)\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  if (!value.document.hasDescendant(key)) return null\n\n  const point = value.document.createPoint({ key, offset })\n  return point\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType == 1 && node.childNodes.length) {\n    const isLast = offset == node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType == 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType == 8 ||\n    (child.nodeType == 1 && child.childNodes.length == 0) ||\n    (child.nodeType == 1 && child.getAttribute('contenteditable') == 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction == 'forward') i++\n    if (direction == 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPoint\n","import getWindow from 'get-window'\nimport { IS_IE, IS_EDGE } from 'slate-dev-environment'\n\nimport findPoint from './find-point'\nimport findDOMPoint from './find-dom-point'\n\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Value} value\n * @return {Range}\n */\n\nfunction findRange(native, value) {\n  const el = native.anchorNode || native.startContainer\n  if (!el) return null\n\n  const window = getWindow(el)\n\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n  if (\n    native instanceof window.Range ||\n    (window.StaticRange && native instanceof window.StaticRange)\n  ) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset,\n    }\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n    isCollapsed,\n  } = native\n  const anchor = findPoint(anchorNode, anchorOffset, value)\n  const focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, value)\n  if (!anchor || !focus) return null\n\n  // COMPAT: ??? The Edge browser seems to have a case where if you select the\n  // last word of a span, it sets the endContainer to the containing span.\n  // `selection-is-backward` doesn't handle this case.\n  if (IS_IE || IS_EDGE) {\n    const domAnchor = findDOMPoint(anchor)\n    const domFocus = findDOMPoint(focus)\n\n    native = {\n      anchorNode: domAnchor.node,\n      anchorOffset: domAnchor.offset,\n      focusNode: domFocus.node,\n      focusOffset: domFocus.offset,\n    }\n  }\n\n  const { document } = value\n  const range = document.createRange({\n    anchor,\n    focus,\n  })\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findRange\n","import getWindow from 'get-window'\nimport isBackward from 'selection-is-backward'\nimport { IS_SAFARI, IS_IOS } from 'slate-dev-environment'\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nconst OVERFLOWS = ['auto', 'overlay', 'scroll']\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nconst IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i)\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  let parent = el.parentNode\n  let scroller\n\n  while (!scroller) {\n    if (!parent.parentNode) break\n\n    const style = window.getComputedStyle(parent)\n    const { overflowY } = style\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent\n      break\n    }\n\n    parent = parent.parentNode\n  }\n\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n  if (!scroller) {\n    return window.document.body\n  }\n\n  return scroller\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return\n  if (!selection.anchorNode) return\n\n  const window = getWindow(selection.anchorNode)\n  const scroller = findScrollContainer(selection.anchorNode, window)\n  const isWindow =\n    scroller == window.document.body ||\n    scroller == window.document.documentElement\n  const backward = isBackward(selection)\n\n  const range = selection.getRangeAt(0).cloneRange()\n  range.collapse(backward)\n  let cursorRect = range.getBoundingClientRect()\n\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top == 0 && cursorRect.height == 0) {\n      if (range.startOffset == 0) {\n        range.setEnd(range.endContainer, 1)\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1)\n      }\n\n      cursorRect = range.getBoundingClientRect()\n\n      if (cursorRect.top == 0 && cursorRect.height == 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0]\n        }\n      }\n    }\n  }\n\n  let width\n  let height\n  let yOffset\n  let xOffset\n  let scrollerTop = 0\n  let scrollerLeft = 0\n  let scrollerBordersY = 0\n  let scrollerBordersX = 0\n  let scrollerPaddingTop = 0\n  let scrollerPaddingBottom = 0\n  let scrollerPaddingLeft = 0\n  let scrollerPaddingRight = 0\n\n  if (isWindow) {\n    const { innerWidth, innerHeight, pageYOffset, pageXOffset } = window\n    width = innerWidth\n    height = innerHeight\n    yOffset = pageYOffset\n    xOffset = pageXOffset\n  } else {\n    const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = scroller\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth,\n      paddingTop,\n      paddingBottom,\n      paddingLeft,\n      paddingRight,\n    } = window.getComputedStyle(scroller)\n\n    const scrollerRect = scroller.getBoundingClientRect()\n    width = offsetWidth\n    height = offsetHeight\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10)\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10)\n\n    scrollerBordersY =\n      parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10)\n\n    scrollerBordersX =\n      parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10)\n\n    scrollerPaddingTop = parseInt(paddingTop, 10)\n    scrollerPaddingBottom = parseInt(paddingBottom, 10)\n    scrollerPaddingLeft = parseInt(paddingLeft, 10)\n    scrollerPaddingRight = parseInt(paddingRight, 10)\n    yOffset = scrollTop\n    xOffset = scrollLeft\n  }\n\n  const cursorTop = cursorRect.top + yOffset - scrollerTop\n  const cursorLeft = cursorRect.left + xOffset - scrollerLeft\n\n  let x = xOffset\n  let y = yOffset\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft\n  } else if (\n    cursorLeft + cursorRect.width + scrollerBordersX >\n    xOffset + width\n  ) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop\n  } else if (\n    cursorTop + cursorRect.height + scrollerBordersY >\n    yOffset + height\n  ) {\n    // selection below viewport\n    y =\n      cursorTop +\n      scrollerBordersY +\n      scrollerPaddingBottom +\n      cursorRect.height -\n      height\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y)\n  } else {\n    scroller.scrollTop = y\n    scroller.scrollLeft = x\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default scrollToSelection\n","/**\n * COMPAT: if we are in <= IE11 and the selection contains\n * tables, `removeAllRanges()` will throw\n * \"unable to complete the operation due to error 800a025e\"\n *\n * @param {Selection} selection document selection\n */\n\nfunction removeAllRanges(selection) {\n  const doc = window.document\n\n  if (doc && doc.body.createTextRange) {\n    // All IE but Edge\n    const range = doc.body.createTextRange()\n    range.collapse()\n    range.select()\n  } else {\n    selection.removeAllRanges()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default removeAllRanges\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport getWindow from 'get-window'\nimport warning from 'slate-dev-warning'\nimport throttle from 'lodash/throttle'\nimport { IS_FIREFOX, HAS_INPUT_EVENTS_LEVEL_2 } from 'slate-dev-environment'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport Node from './node'\nimport findDOMRange from '../utils/find-dom-range'\nimport findRange from '../utils/find-range'\nimport getChildrenDecorations from '../utils/get-children-decorations'\nimport scrollToSelection from '../utils/scroll-to-selection'\nimport removeAllRanges from '../utils/remove-all-ranges'\n\nconst FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:content')\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nclass Content extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool.isRequired,\n    className: Types.string,\n    editor: Types.object.isRequired,\n    readOnly: Types.bool.isRequired,\n    role: Types.string,\n    spellCheck: Types.bool.isRequired,\n    style: Types.object,\n    tabIndex: Types.number,\n    tagName: Types.string,\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: {},\n    tagName: 'div',\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    isUpdatingSelection: false,\n  }\n\n  /**\n   * Create a set of bound event handlers.\n   *\n   * @type {Object}\n   */\n\n  handlers = EVENT_HANDLERS.reduce((obj, handler) => {\n    obj[handler] = event => this.onEvent(handler, event)\n    return obj\n  }, {})\n\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Add native DOM event listeners.\n   *   - Update the selection, in case it starts focused.\n   */\n\n  componentDidMount() {\n    const window = getWindow(this.element)\n\n    window.document.addEventListener(\n      'selectionchange',\n      this.onNativeSelectionChange\n    )\n\n    // COMPAT: Restrict scope of `beforeinput` to clients that support the\n    // Input Events Level 2 spec, since they are preventable events.\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.element.addEventListener('beforeinput', this.handlers.onBeforeInput)\n    }\n\n    this.updateSelection()\n  }\n\n  /**\n   * When unmounting, remove DOM event listeners.\n   */\n\n  componentWillUnmount() {\n    const window = getWindow(this.element)\n\n    if (window) {\n      window.document.removeEventListener(\n        'selectionchange',\n        this.onNativeSelectionChange\n      )\n    }\n\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.element.removeEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n  }\n\n  /**\n   * On update, update the selection.\n   */\n\n  componentDidUpdate() {\n    this.updateSelection()\n  }\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  updateSelection = () => {\n    const { editor } = this.props\n    const { value } = editor\n    const { selection } = value\n    const { isBackward } = selection\n    const window = getWindow(this.element)\n    const native = window.getSelection()\n\n    // .getSelection() can return null in some cases\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=827585\n    if (!native) return\n\n    const { rangeCount, anchorNode } = native\n\n    // If both selections are blurred, do nothing.\n    if (!rangeCount && selection.isBlurred) return\n\n    // If the selection has been blurred, but is still inside the editor in the\n    // DOM, blur it manually.\n    if (selection.isBlurred) {\n      if (!this.isInEditor(anchorNode)) return\n      removeAllRanges(native)\n      this.element.blur()\n      debug('updateSelection', { selection, native })\n      return\n    }\n\n    // If the selection isn't set, do nothing.\n    if (selection.isUnset) return\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    const current = !!rangeCount && native.getRangeAt(0)\n    const range = findDOMRange(selection, window)\n\n    if (!range) {\n      warning(\n        false,\n        'Unable to find a native DOM range from the current selection.'\n      )\n\n      return\n    }\n\n    const { startContainer, startOffset, endContainer, endOffset } = range\n\n    // If the new range matches the current selection, there is nothing to fix.\n    // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n    // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n    // to check both orientations here. (2017/10/31)\n    if (current) {\n      if (\n        (startContainer == current.startContainer &&\n          startOffset == current.startOffset &&\n          endContainer == current.endContainer &&\n          endOffset == current.endOffset) ||\n        (startContainer == current.endContainer &&\n          startOffset == current.endOffset &&\n          endContainer == current.startContainer &&\n          endOffset == current.startOffset)\n      ) {\n        return\n      }\n    }\n\n    // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n    this.tmp.isUpdatingSelection = true\n    removeAllRanges(native)\n\n    // COMPAT: IE 11 does not support Selection.setBaseAndExtent\n    if (native.setBaseAndExtent) {\n      // COMPAT: Since the DOM range has no concept of backwards/forwards\n      // we need to check and do the right thing here.\n      if (isBackward) {\n        native.setBaseAndExtent(\n          range.endContainer,\n          range.endOffset,\n          range.startContainer,\n          range.startOffset\n        )\n      } else {\n        native.setBaseAndExtent(\n          range.startContainer,\n          range.startOffset,\n          range.endContainer,\n          range.endOffset\n        )\n      }\n    } else {\n      // COMPAT: IE 11 does not support Selection.extend, fallback to addRange\n      native.addRange(range)\n    }\n\n    // Scroll to the selection, in case it's out of view.\n    scrollToSelection(native)\n\n    // Then unset the `isUpdatingSelection` flag after a delay.\n    setTimeout(() => {\n      // COMPAT: In Firefox, it's not enough to create a range, you also need to\n      // focus the contenteditable element too. (2016/11/16)\n      if (IS_FIREFOX && this.element) this.element.focus()\n      this.tmp.isUpdatingSelection = false\n    })\n\n    debug('updateSelection', { selection, native })\n  }\n\n  /**\n   * The React ref method to set the root content element locally.\n   *\n   * @param {Element} element\n   */\n\n  ref = element => {\n    this.element = element\n  }\n\n  /**\n   * Check if an event `target` is fired from within the contenteditable\n   * element. This should be false for edits happening in non-contenteditable\n   * children, such as void nodes and other nested Slate editors.\n   *\n   * @param {Element} target\n   * @return {Boolean}\n   */\n\n  isInEditor = target => {\n    const { element } = this\n\n    let el\n\n    try {\n      // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n      // have .closest and it crashes.\n      if (target.nodeType === 8) {\n        return false\n      }\n\n      // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n      // `target` is a text node use its parent node for check.\n      el = target.nodeType === 3 ? target.parentNode : target\n    } catch (err) {\n      // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n      // originating from an internal \"restricted\" element (e.g. a stepper\n      // arrow on a number input)\n      // see github.com/ianstormtaylor/slate/issues/1819\n      if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n        return false\n      }\n\n      throw err\n    }\n\n    const allowEdit = el.isContentEditable || el.closest('[data-slate-void]')\n    return (\n      allowEdit &&\n      (el === element || el.closest('[data-slate-editor]') === element)\n    )\n  }\n\n  /**\n   * On `event` with `handler`.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  onEvent(handler, event) {\n    debug('onEvent', handler)\n\n    // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n    // programmatically while updating selection.\n    if (\n      this.tmp.isUpdatingSelection &&\n      (handler == 'onSelect' || handler == 'onBlur' || handler == 'onFocus')\n    ) {\n      return\n    }\n\n    // COMPAT: There are situations where a select event will fire with a new\n    // native selection that resolves to the same internal position. In those\n    // cases we don't need to trigger any changes, since our internal model is\n    // already up to date, but we do want to update the native selection again\n    // to make sure it is in sync. (2017/10/16)\n    if (handler == 'onSelect') {\n      const { editor } = this.props\n      const { value } = editor\n      const { selection } = value\n      const window = getWindow(event.target)\n      const native = window.getSelection()\n      const range = findRange(native, value)\n\n      if (range && range.equals(selection.toRange())) {\n        this.updateSelection()\n        return\n      }\n    }\n\n    // Don't handle drag and drop events coming from embedded editors.\n    if (\n      handler == 'onDragEnd' ||\n      handler == 'onDragEnter' ||\n      handler == 'onDragExit' ||\n      handler == 'onDragLeave' ||\n      handler == 'onDragOver' ||\n      handler == 'onDragStart' ||\n      handler == 'onDrop'\n    ) {\n      const { target } = event\n      const targetEditorNode = target.closest('[data-slate-editor]')\n      if (targetEditorNode !== this.element) return\n    }\n\n    // Some events require being in editable in the editor, so if the event\n    // target isn't, ignore them.\n    if (\n      handler == 'onBeforeInput' ||\n      handler == 'onBlur' ||\n      handler == 'onCompositionEnd' ||\n      handler == 'onCompositionStart' ||\n      handler == 'onCopy' ||\n      handler == 'onCut' ||\n      handler == 'onFocus' ||\n      handler == 'onInput' ||\n      handler == 'onKeyDown' ||\n      handler == 'onKeyUp' ||\n      handler == 'onPaste' ||\n      handler == 'onSelect'\n    ) {\n      if (!this.isInEditor(event.target)) return\n    }\n\n    this.props[handler](event)\n  }\n\n  /**\n   * On native `selectionchange` event, trigger the `onSelect` handler. This is\n   * needed to account for React's `onSelect` being non-standard and not firing\n   * until after a selection has been released. This causes issues in situations\n   * where another change happens while a selection is being made.\n   *\n   * @param {Event} event\n   */\n\n  onNativeSelectionChange = throttle(event => {\n    if (this.props.readOnly) return\n\n    const window = getWindow(event.target)\n    const { activeElement } = window.document\n    if (activeElement !== this.element) return\n\n    this.props.onSelect(event)\n  }, 100)\n\n  /**\n   * Render the editor content.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props, handlers } = this\n    const {\n      className,\n      readOnly,\n      editor,\n      tabIndex,\n      role,\n      tagName,\n      spellCheck,\n    } = props\n    const { value, stack } = editor\n    const Container = tagName\n    const { document, selection, decorations } = value\n    const indexes = document.getSelectionIndexes(selection)\n    const decs = document.getDecorations(stack).concat(decorations)\n    const childrenDecorations = getChildrenDecorations(document, decs)\n\n    const children = document.nodes.toArray().map((child, i) => {\n      const isSelected = !!indexes && indexes.start <= i && i < indexes.end\n\n      return this.renderNode(child, isSelected, childrenDecorations[i])\n    })\n\n    const style = {\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word',\n      // COMPAT: In iOS, a formatting menu with bold, italic and underline\n      // buttons is shown which causes our internal value to get out of sync in\n      // weird ways. This hides that. (2016/06/21)\n      ...(readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }),\n      // Allow for passed-in styles to override anything.\n      ...props.style,\n    }\n\n    debug('render', { props })\n\n    return (\n      <Container\n        {...handlers}\n        data-slate-editor\n        ref={this.ref}\n        data-key={document.key}\n        contentEditable={readOnly ? null : true}\n        suppressContentEditableWarning\n        className={className}\n        autoCorrect={props.autoCorrect ? 'on' : 'off'}\n        spellCheck={spellCheck}\n        style={style}\n        role={readOnly ? null : role || 'textbox'}\n        tabIndex={tabIndex}\n        // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        data-gramm={false}\n      >\n        {children}\n      </Container>\n    )\n  }\n\n  /**\n   * Render a `child` node of the document.\n   *\n   * @param {Node} child\n   * @param {Boolean} isSelected\n   * @return {Element}\n   */\n\n  renderNode = (child, isSelected, decorations) => {\n    const { editor, readOnly } = this.props\n    const { value } = editor\n    const { document, selection } = value\n    const { isFocused } = selection\n\n    return (\n      <Node\n        block={null}\n        editor={editor}\n        decorations={decorations}\n        isSelected={isSelected}\n        isFocused={isFocused && isSelected}\n        key={child.key}\n        node={child}\n        parent={document}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Mix in handler prop types.\n */\n\nEVENT_HANDLERS.forEach(handler => {\n  Content.propTypes[handler] = Types.func.isRequired\n})\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Content\n","/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nconst TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain',\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default TRANSFER_TYPES\n","import Base64 from 'slate-base64-serializer'\nimport Plain from 'slate-plain-serializer'\nimport { Value } from 'slate'\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport getWindow from 'get-window'\nimport findDOMNode from './find-dom-node'\nimport removeAllRanges from './remove-all-ranges'\nimport { IS_IE } from 'slate-dev-environment'\nimport { ZERO_WIDTH_SELECTOR, ZERO_WIDTH_ATTRIBUTE } from './find-point'\n\nconst { FRAGMENT, HTML, TEXT } = TRANSFER_TYPES\n\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Value} value\n * @param {Document} [fragment]\n */\n\nfunction cloneFragment(\n  event,\n  value,\n  fragment = value.fragment,\n  callback = () => undefined\n) {\n  const window = getWindow(event.target)\n  const native = window.getSelection()\n  const { schema } = value\n  const { start, end } = value.selection\n  const startVoid = value.document.getClosestVoid(start.key, schema)\n  const endVoid = value.document.getClosestVoid(end.key, schema)\n\n  // If the selection is collapsed, and it isn't inside a void node, abort.\n  if (native.isCollapsed && !startVoid) return\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  const encoded = Base64.serializeNode(fragment)\n  const range = native.getRangeAt(0)\n  let contents = range.cloneContents()\n  let attach = contents.childNodes[0]\n\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\n  contents.childNodes.forEach(node => {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node\n    }\n  })\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    const r = range.cloneRange()\n    const node = findDOMNode(endVoid, window)\n    r.setEndAfter(node)\n    contents = r.cloneContents()\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  ;[].slice.call(contents.querySelectorAll(ZERO_WIDTH_SELECTOR)).forEach(zw => {\n    const isNewline = zw.getAttribute(ZERO_WIDTH_ATTRIBUTE) === 'n'\n    zw.textContent = isNewline ? '\\n' : ''\n  })\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (attach.nodeType == 3) {\n    const span = window.document.createElement('span')\n\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre'\n\n    span.appendChild(attach)\n    contents.appendChild(span)\n    attach = span\n  }\n\n  attach.setAttribute('data-slate-fragment', encoded)\n\n  //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n  const valFromSelection = Value.create({ document: fragment })\n  const plainText = Plain.serialize(valFromSelection)\n\n  // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n  const div = window.document.createElement('div')\n  div.appendChild(contents)\n\n  // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault()\n    event.clipboardData.setData(TEXT, plainText)\n    event.clipboardData.setData(FRAGMENT, encoded)\n    event.clipboardData.setData(HTML, div.innerHTML)\n    callback()\n  }\n\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n  const editor = event.target.closest('[data-slate-editor]')\n  div.setAttribute('contenteditable', true)\n  div.style.position = 'absolute'\n  div.style.left = '-9999px'\n  editor.appendChild(div)\n  native.selectAllChildren(div)\n\n  // Revert to the previous selection right after copying.\n  window.requestAnimationFrame(() => {\n    editor.removeChild(div)\n    removeAllRanges(native)\n    native.addRange(range)\n    callback()\n  })\n}\n\nexport default cloneFragment\n","/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Value} value\n * @return {Node|Null}\n */\n\nfunction findNode(element, value) {\n  const closest = element.closest('[data-key]')\n  if (!closest) return null\n\n  const key = closest.getAttribute('data-key')\n  if (!key) return null\n\n  const node = value.document.getNode(key)\n  return node || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findNode\n","import getWindow from 'get-window'\n\nimport findNode from './find-node'\nimport findRange from './find-range'\n\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Value} value\n * @return {Range}\n */\n\nfunction getEventRange(event, value) {\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const { x, y, target } = event\n  if (x == null || y == null) return null\n\n  const { document, schema } = value\n  const node = findNode(target, value)\n  if (!node) return null\n\n  // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n  if (schema.isVoid(node)) {\n    const rect = target.getBoundingClientRect()\n    const isPrevious =\n      node.object == 'inline'\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n    const text = node.getFirstText()\n    const range = document.createRange()\n\n    if (isPrevious) {\n      const previousText = document.getPreviousText(text.key)\n\n      if (previousText) {\n        return range.moveToEndOfNode(previousText)\n      }\n    }\n\n    const nextText = document.getNextText(text.key)\n    return nextText ? range.moveToStartOfNode(nextText) : null\n  }\n\n  // Else resolve a range from the caret position where the drop occured.\n  const window = getWindow(target)\n  let native\n\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y)\n  } else if (window.document.caretPositionFromPoint) {\n    const position = window.document.caretPositionFromPoint(x, y)\n    native = window.document.createRange()\n    native.setStart(position.offsetNode, position.offset)\n    native.setEnd(position.offsetNode, position.offset)\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange()\n\n    try {\n      native.moveToPoint(x, y)\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null\n    }\n  }\n\n  // Resolve a Slate range from the DOM range.\n  const range = findRange(native, value)\n  if (!range) return null\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventRange\n","import Base64 from 'slate-base64-serializer'\nimport { IS_IE } from 'slate-dev-environment'\nimport TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nconst { FRAGMENT, HTML, NODE, RICH, TEXT } = TRANSFER_TYPES\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nconst FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n  let fragment = getType(transfer, FRAGMENT)\n  let node = getType(transfer, NODE)\n  const html = getType(transfer, HTML)\n  const rich = getType(transfer, RICH)\n  let text = getType(transfer, TEXT)\n  let files\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(' data-slate-fragment=\"')) {\n    const matches = FRAGMENT_MATCHER.exec(html)\n    const [full, encoded] = matches // eslint-disable-line no-unused-vars\n    if (encoded) fragment = encoded\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    const embeddedTypes = getEmbeddedTypes(text)\n\n    if (embeddedTypes[FRAGMENT]) fragment = embeddedTypes[FRAGMENT]\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE]\n    if (embeddedTypes[TEXT]) text = embeddedTypes[TEXT]\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = Base64.deserializeNode(fragment)\n  if (node) node = Base64.deserializeNode(node)\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items)\n        .map(item => (item.kind == 'file' ? item.getAsFile() : null))\n        .filter(exists => exists)\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  }\n\n  // Determine the type of the data.\n  const data = { files, fragment, html, node, rich, text }\n  data.type = getTransferType(data)\n  return data\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  const prefix = 'SLATE-DATA-EMBED::'\n\n  if (text.substring(0, prefix.length) != prefix) {\n    return { TEXT: text }\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length))\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.')\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment'\n  if (data.node) return 'node'\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html'\n  if (data.rich && data.text) return 'text'\n\n  if (data.files && data.files.length) return 'files'\n  if (data.html) return 'html'\n  if (data.text) return 'text'\n  return 'unknown'\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type == TEXT ? transfer.getData('Text') || null : null\n  }\n\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n  const types = Array.from(transfer.types)\n\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventTransfer\n","import TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nconst { TEXT } = TRANSFER_TYPES\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  const mime = TRANSFER_TYPES[type.toUpperCase()]\n\n  if (!mime) {\n    throw new Error(`Cannot set unknown transfer type \"${mime}\".`)\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n\n  try {\n    transfer.setData(mime, content)\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n    transfer.setData('text', transfer.getData('text'))\n  } catch (err) {\n    const prefix = 'SLATE-DATA-EMBED::'\n    const text = transfer.getData(TEXT)\n    let obj = {}\n\n    // If the existing plain text data is prefixed, it's Slate JSON data.\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length))\n      } catch (e) {\n        throw new Error(\n          'Failed to parse Slate data from `DataTransfer` object.'\n        )\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT] = text\n    }\n\n    obj[mime] = content\n    const string = `${prefix}${JSON.stringify(obj)}`\n    transfer.setData(TEXT, string)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default setEventTransfer\n","import Base64 from 'slate-base64-serializer'\nimport Debug from 'debug'\nimport Plain from 'slate-plain-serializer'\nimport { IS_IOS } from 'slate-dev-environment'\nimport React from 'react'\nimport getWindow from 'get-window'\nimport { Text } from 'slate'\nimport Hotkeys from 'slate-hotkeys'\n\nimport Content from '../components/content'\nimport cloneFragment from '../utils/clone-fragment'\nimport findDOMNode from '../utils/find-dom-node'\nimport findNode from '../utils/find-node'\nimport findPoint from '../utils/find-point'\nimport findRange from '../utils/find-range'\nimport getEventRange from '../utils/get-event-range'\nimport getEventTransfer from '../utils/get-event-transfer'\nimport setEventTransfer from '../utils/set-event-transfer'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:after')\n\n/**\n * The after plugin.\n *\n * @return {Object}\n */\n\nfunction AfterPlugin() {\n  let isDraggingInternally = null\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onBeforeInput(event, change, editor) {\n    debug('onBeforeInput', { event })\n\n    const isSynthetic = !!event.nativeEvent\n\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n    if (isSynthetic) {\n      event.preventDefault()\n      change.insertText(event.data)\n      return\n    }\n\n    // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n    const [targetRange] = event.getTargetRanges()\n    if (!targetRange) return\n\n    event.preventDefault()\n\n    const { value } = change\n    const { document, selection, schema } = value\n    const range = findRange(targetRange, value)\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward': {\n        change.deleteAtRange(range)\n        return\n      }\n\n      case 'deleteWordBackward': {\n        change.deleteWordBackwardAtRange(range)\n        return\n      }\n\n      case 'deleteWordForward': {\n        change.deleteWordForwardAtRange(range)\n        return\n      }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward': {\n        change.deleteLineBackwardAtRange(range)\n        return\n      }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward': {\n        change.deleteLineForwardAtRange(range)\n        return\n      }\n\n      case 'insertLineBreak':\n      case 'insertParagraph': {\n        const hasVoidParent = document.hasVoidParent(\n          selection.start.path,\n          schema\n        )\n\n        if (hasVoidParent) {\n          change.moveToStartOfNextText()\n        } else {\n          change.splitBlockAtRange(range)\n        }\n\n        return\n      }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText': {\n        // COMPAT: `data` should have the text for the `insertText` input type\n        // and `dataTransfer` should have the text for the\n        // `insertReplacementText` input type, but Safari uses `insertText` for\n        // spell check replacements and sets `data` to `null`. (2018/08/09)\n        const text =\n          event.data == null\n            ? event.dataTransfer.getData('text/plain')\n            : event.data\n\n        if (text == null) return\n\n        change.insertTextAtRange(range, text, selection.marks)\n\n        // If the text was successfully inserted, and the selection had marks\n        // on it, unset the selection's marks.\n        if (selection.marks && value.document != change.value.document) {\n          change.select({ marks: null })\n        }\n\n        return\n      }\n    }\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onBlur(event, change, editor) {\n    debug('onBlur', { event })\n\n    change.blur()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onClick(event, change, editor) {\n    if (editor.props.readOnly) {\n      return true\n    }\n\n    const { value } = change\n    const { document, schema } = value\n    const node = findNode(event.target, value)\n\n    if (!node) {\n      return\n    }\n\n    const ancestors = document.getAncestors(node.key)\n    const isVoid =\n      node && (schema.isVoid(node) || ancestors.some(a => schema.isVoid(a)))\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      change.focus().moveToEndOfNode(node)\n    }\n\n    debug('onClick', { event })\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onCopy(event, change, editor) {\n    debug('onCopy', { event })\n\n    cloneFragment(event, change.value)\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onCut(event, change, editor) {\n    debug('onCut', { event })\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    cloneFragment(event, change.value, change.value.fragment, () => {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      const { value } = change\n      const { endBlock, endInline, selection, schema } = value\n      const { isCollapsed } = selection\n      const isVoidBlock = endBlock && schema.isVoid(endBlock) && isCollapsed\n      const isVoidInline = endInline && schema.isVoid(endInline) && isCollapsed\n\n      if (isVoidBlock) {\n        editor.change(c => c.removeNodeByKey(endBlock.key))\n      } else if (isVoidInline) {\n        editor.change(c => c.removeNodeByKey(endInline.key))\n      } else {\n        editor.change(c => c.delete())\n      }\n    })\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragEnd(event, change, editor) {\n    debug('onDragEnd', { event })\n\n    isDraggingInternally = null\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragOver(event, change, editor) {\n    debug('onDragOver', { event })\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragStart(event, change, editor) {\n    debug('onDragStart', { event })\n\n    isDraggingInternally = true\n\n    const { value } = change\n    const { document, schema } = value\n    const node = findNode(event.target, value)\n    const ancestors = document.getAncestors(node.key)\n    const isVoid =\n      node && (schema.isVoid(node) || ancestors.some(a => schema.isVoid(a)))\n    const selectionIncludesNode = value.blocks.some(\n      block => block.key === node.key\n    )\n\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\n    if (isVoid && !selectionIncludesNode) {\n      change.moveToRangeOfNode(node)\n    }\n\n    const fragment = change.value.fragment\n    const encoded = Base64.serializeNode(fragment)\n    setEventTransfer(event, 'fragment', encoded)\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDrop(event, change, editor) {\n    debug('onDrop', { event })\n\n    const { value } = change\n    const { document, selection, schema } = value\n    const window = getWindow(event.target)\n    let target = getEventRange(event, value)\n    if (!target) return\n\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    change.focus()\n\n    // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n    if (\n      isDraggingInternally &&\n      selection.end.key == target.end.key &&\n      selection.end.offset < target.end.offset\n    ) {\n      target = target.moveForward(\n        selection.start.key == selection.end.key\n          ? 0 - selection.end.offset + selection.start.offset\n          : 0 - selection.end.offset\n      )\n    }\n\n    if (isDraggingInternally) {\n      change.delete()\n    }\n\n    change.select(target)\n\n    if (type == 'text' || type == 'html') {\n      const { anchor } = target\n      let hasVoidParent = document.hasVoidParent(anchor.key, schema)\n\n      if (hasVoidParent) {\n        let n = document.getNode(anchor.key)\n\n        while (hasVoidParent) {\n          n = document.getNextText(n.key)\n          if (!n) break\n          hasVoidParent = document.hasVoidParent(n.key, schema)\n        }\n\n        if (n) change.moveToStartOfNode(n)\n      }\n\n      if (text) {\n        text.split('\\n').forEach((line, i) => {\n          if (i > 0) change.splitBlock()\n          change.insertText(line)\n        })\n      }\n    }\n\n    if (type == 'fragment') {\n      change.insertFragment(fragment)\n    }\n\n    // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n    const focusNode = document.getNode(target.focus.key)\n    const el = findDOMNode(focusNode, window)\n    if (!el) return\n\n    el.dispatchEvent(\n      new MouseEvent('mouseup', {\n        view: window,\n        bubbles: true,\n        cancelable: true,\n      })\n    )\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} eventvent\n   * @param {Change} change\n   */\n\n  function onInput(event, change, editor) {\n    debug('onInput', { event })\n\n    const window = getWindow(event.target)\n    const { value } = change\n\n    // Get the selection point.\n    const native = window.getSelection()\n    const { anchorNode } = native\n    const point = findPoint(anchorNode, 0, value)\n    if (!point) return\n\n    // Get the text node and leaf in question.\n    const { document, selection } = value\n    const node = document.getDescendant(point.key)\n    const block = document.getClosestBlock(node.key)\n    const leaves = node.getLeaves()\n    const lastText = block.getLastText()\n    const lastLeaf = leaves.last()\n    let start = 0\n    let end = 0\n\n    const leaf =\n      leaves.find(r => {\n        start = end\n        end += r.text.length\n        if (end > point.offset) return true\n      }) || lastLeaf\n\n    // Get the text information.\n    const { text } = leaf\n    let { textContent } = anchorNode\n    const isLastText = node == lastText\n    const isLastLeaf = leaf == lastLeaf\n    const lastChar = textContent.charAt(textContent.length - 1)\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    if (isLastText && isLastLeaf && lastChar == '\\n') {\n      textContent = textContent.slice(0, -1)\n    }\n\n    // If the text is no different, abort.\n    if (textContent == text) return\n\n    // Determine what the selection should be after changing the text.\n    const delta = textContent.length - text.length\n    const corrected = selection.moveToEnd().moveForward(delta)\n    let entire = selection\n      .moveAnchorTo(point.key, start)\n      .moveFocusTo(point.key, end)\n\n    entire = document.resolveRange(entire)\n\n    // Change the current value to have the leaf's text replaced.\n    change.insertTextAtRange(entire, textContent, leaf.marks).select(corrected)\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onKeyDown(event, change, editor) {\n    debug('onKeyDown', { event })\n\n    const { value } = change\n    const { document, selection, schema } = value\n    const hasVoidParent = document.hasVoidParent(selection.start.path, schema)\n\n    // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent\n        ? change.moveToStartOfNextText()\n        : change.splitBlock()\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return change.deleteCharBackward()\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return change.deleteCharForward()\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return change.deleteLineBackward()\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return change.deleteLineForward()\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return change.deleteWordBackward()\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return change.deleteWordForward()\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return change.redo()\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return change.undo()\n    }\n\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault()\n      return change.moveToStartOfBlock()\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault()\n      return change.moveToEndOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      return change.moveFocusToStartOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      return change.moveFocusToEndOfBlock()\n    }\n\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n    if (Hotkeys.isMoveBackward(event)) {\n      const { previousText, startText } = value\n      const isPreviousInVoid =\n        previousText && document.hasVoidParent(previousText.key, schema)\n\n      if (hasVoidParent || isPreviousInVoid || startText.text == '') {\n        event.preventDefault()\n        return change.moveBackward()\n      }\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      const { nextText, startText } = value\n      const isNextInVoid =\n        nextText && document.hasVoidParent(nextText.key, schema)\n\n      if (hasVoidParent || isNextInVoid || startText.text == '') {\n        event.preventDefault()\n        return change.moveForward()\n      }\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      const { previousText, startText } = value\n      const isPreviousInVoid =\n        previousText && document.hasVoidParent(previousText.key, schema)\n\n      if (hasVoidParent || isPreviousInVoid || startText.text == '') {\n        event.preventDefault()\n        return change.moveFocusBackward()\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      const { nextText, startText } = value\n      const isNextInVoid =\n        nextText && document.hasVoidParent(nextText.key, schema)\n\n      if (hasVoidParent || isNextInVoid || startText.text == '') {\n        event.preventDefault()\n        return change.moveFocusForward()\n      }\n    }\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onPaste(event, change, editor) {\n    debug('onPaste', { event })\n\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    if (type == 'fragment') {\n      change.insertFragment(fragment)\n    }\n\n    if (type == 'text' || type == 'html') {\n      if (!text) return\n      const { value } = change\n      const { document, selection, startBlock, schema } = value\n      if (schema.isVoid(startBlock)) return\n\n      const defaultBlock = startBlock\n      const defaultMarks = document.getInsertMarksAtRange(selection)\n      const frag = Plain.deserialize(text, { defaultBlock, defaultMarks })\n        .document\n      change.insertFragment(frag)\n    }\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onSelect(event, change, editor) {\n    debug('onSelect', { event })\n\n    const window = getWindow(event.target)\n    const { value } = change\n    const { document, schema } = value\n    const native = window.getSelection()\n\n    // If there are no ranges, the editor was blurred natively.\n    if (!native.rangeCount) {\n      change.blur()\n      return\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    let range = findRange(native, value)\n    if (!range) return\n\n    const { anchor, focus } = range\n    const anchorText = document.getNode(anchor.key)\n    const focusText = document.getNode(focus.key)\n    const anchorInline = document.getClosestInline(anchor.key)\n    const focusInline = document.getClosestInline(focus.key)\n    const focusBlock = document.getClosestBlock(focus.key)\n    const anchorBlock = document.getClosestBlock(anchor.key)\n\n    // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n    if (\n      anchorBlock &&\n      !schema.isVoid(anchorBlock) &&\n      anchor.offset == 0 &&\n      focusBlock &&\n      schema.isVoid(focusBlock) &&\n      focus.offset != 0\n    ) {\n      range = range.setFocus(focus.setOffset(0))\n    }\n\n    // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n    if (\n      anchorInline &&\n      !schema.isVoid(anchorInline) &&\n      anchor.offset == anchorText.text.length\n    ) {\n      const block = document.getClosestBlock(anchor.key)\n      const next = block.getNextText(anchor.key)\n      if (next) range = range.moveAnchorTo(next.key, 0)\n    }\n\n    if (\n      focusInline &&\n      !schema.isVoid(focusInline) &&\n      focus.offset == focusText.text.length\n    ) {\n      const block = document.getClosestBlock(focus.key)\n      const next = block.getNextText(focus.key)\n      if (next) range = range.moveFocusTo(next.key, 0)\n    }\n\n    let selection = document.createSelection(range)\n    selection = selection.setIsFocused(true)\n\n    // Preserve active marks from the current selection.\n    // They will be cleared by `change.select` if the selection actually moved.\n    selection = selection.set('marks', value.selection.marks)\n\n    change.select(selection)\n  }\n\n  /**\n   * Render editor.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @return {Object}\n   */\n\n  function renderEditor(props, editor) {\n    const { handlers } = editor\n    return (\n      <Content\n        {...handlers}\n        autoCorrect={props.autoCorrect}\n        className={props.className}\n        editor={editor}\n        readOnly={props.readOnly}\n        role={props.role}\n        spellCheck={props.spellCheck}\n        style={props.style}\n        tabIndex={props.tabIndex}\n        tagName={props.tagName}\n      />\n    )\n  }\n\n  /**\n   * Render node.\n   *\n   * @param {Object} props\n   * @return {Element}\n   */\n\n  function renderNode(props) {\n    const { attributes, children, node } = props\n    if (node.object != 'block' && node.object != 'inline') return\n    const Tag = node.object == 'block' ? 'div' : 'span'\n    const style = { position: 'relative' }\n    return (\n      <Tag {...attributes} style={style}>\n        {children}\n      </Tag>\n    )\n  }\n\n  /**\n   * Render placeholder.\n   *\n   * @param {Object} props\n   * @return {Element}\n   */\n\n  function renderPlaceholder(props) {\n    const { editor, node } = props\n    if (!editor.props.placeholder) return\n    if (editor.state.isComposing) return\n    if (node.object != 'block') return\n    if (!Text.isTextList(node.nodes)) return\n    if (node.text != '') return\n    if (editor.value.document.getBlocks().size > 1) return\n\n    const style = {\n      pointerEvents: 'none',\n      display: 'inline-block',\n      width: '0',\n      maxWidth: '100%',\n      whiteSpace: 'nowrap',\n      opacity: '0.333',\n    }\n\n    return (\n      <span contentEditable={false} style={style}>\n        {editor.props.placeholder}\n      </span>\n    )\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragOver,\n    onDragStart,\n    onDrop,\n    onInput,\n    onKeyDown,\n    onPaste,\n    onSelect,\n    renderEditor,\n    renderNode,\n    renderPlaceholder,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default AfterPlugin\n","import Debug from 'debug'\nimport getWindow from 'get-window'\nimport { findDOMNode } from 'react-dom'\nimport Hotkeys from 'slate-hotkeys'\nimport {\n  IS_FIREFOX,\n  IS_IE,\n  IS_IOS,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport findNode from '../utils/find-node'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:before')\n\n/**\n * The core before plugin.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  let activeElement = null\n  let compositionCount = 0\n  let isComposing = false\n  let isCopying = false\n  let isDragging = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onBeforeInput(event, change, editor) {\n    if (editor.props.readOnly) return true\n\n    const isSynthetic = !!event.nativeEvent\n\n    // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return true\n\n    debug('onBeforeInput', { event })\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onBlur(event, change, editor) {\n    if (isCopying) return true\n    if (editor.props.readOnly) return true\n\n    const { value } = change\n    const { schema } = value\n    const { relatedTarget, target } = event\n    const window = getWindow(target)\n\n    // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n    if (activeElement == window.document.activeElement) return true\n\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n    if (relatedTarget) {\n      const el = findDOMNode(editor)\n\n      // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n      if (relatedTarget == el) return true\n\n      // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n      if (relatedTarget.hasAttribute('data-slate-spacer')) return true\n\n      // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n      const node = findNode(relatedTarget, value)\n      if (el.contains(relatedTarget) && node && !schema.isVoid(node))\n        return true\n    }\n\n    debug('onBlur', { event })\n  }\n\n  /**\n   * On change.\n   *\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onChange(change, editor) {\n    const { value } = change\n\n    // If the value's schema isn't the editor's schema, update it. This can\n    // happen on the initialization of the editor, or if the schema changes.\n    // This change isn't save into history since only schema is updated.\n    if (value.schema != editor.schema) {\n      change.withoutSaving(() => {\n        change.setValue({ schema: editor.schema }).normalize()\n      })\n    }\n\n    debug('onChange')\n  }\n\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onCompositionEnd(event, change, editor) {\n    const n = compositionCount\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n    window.requestAnimationFrame(() => {\n      if (compositionCount > n) return\n      isComposing = false\n\n      // HACK: we need to re-render the editor here so that it will update its\n      // placeholder in case one is currently rendered. This should be handled\n      // differently ideally, in a less invasive way?\n      // (apply force re-render if isComposing changes)\n      if (editor.state.isComposing) {\n        editor.setState({ isComposing: false })\n      }\n    })\n\n    debug('onCompositionEnd', { event })\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onCompositionStart(event, change, editor) {\n    isComposing = true\n    compositionCount++\n\n    // HACK: we need to re-render the editor here so that it will update its\n    // placeholder in case one is currently rendered. This should be handled\n    // differently ideally, in a less invasive way?\n    // (apply force re-render if isComposing changes)\n    if (!editor.state.isComposing) {\n      editor.setState({ isComposing: true })\n    }\n\n    debug('onCompositionStart', { event })\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onCopy(event, change, editor) {\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCopy', { event })\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onCut(event, change, editor) {\n    if (editor.props.readOnly) return true\n\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCut', { event })\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragEnd(event, change, editor) {\n    isDragging = false\n\n    debug('onDragEnd', { event })\n  }\n\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragEnter(event, change, editor) {\n    debug('onDragEnter', { event })\n  }\n\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragExit(event, change, editor) {\n    debug('onDragExit', { event })\n  }\n\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragLeave(event, change, editor) {\n    debug('onDragLeave', { event })\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragOver(event, change, editor) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    const { value } = editor\n    const { schema } = value\n    const node = findNode(event.target, editor.value)\n    if (schema.isVoid(node)) event.preventDefault()\n\n    // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n    if (IS_IE) event.preventDefault()\n\n    // If a drag is already in progress, don't do this again.\n    if (!isDragging) {\n      isDragging = true\n\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move'\n      }\n    }\n\n    debug('onDragOver', { event })\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDragStart(event, change, editor) {\n    isDragging = true\n\n    debug('onDragStart', { event })\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onDrop(event, change, editor) {\n    // Nothing happens in read-only mode.\n    if (editor.props.readOnly) return true\n\n    // Prevent default so the DOM's value isn't corrupted.\n    event.preventDefault()\n\n    debug('onDrop', { event })\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onFocus(event, change, editor) {\n    if (isCopying) return true\n    if (editor.props.readOnly) return true\n\n    const el = findDOMNode(editor)\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (IS_FIREFOX && event.target != el) {\n      el.focus()\n      return true\n    }\n\n    debug('onFocus', { event })\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onInput(event, change, editor) {\n    if (isComposing) return true\n    if (change.value.selection.isBlurred) return true\n\n    debug('onInput', { event })\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onKeyDown(event, change, editor) {\n    if (editor.props.readOnly) return true\n\n    // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault()\n      return true\n    }\n\n    // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will change the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n    if (\n      !IS_IOS &&\n      (Hotkeys.isBold(event) ||\n        Hotkeys.isDeleteBackward(event) ||\n        Hotkeys.isDeleteForward(event) ||\n        Hotkeys.isDeleteLineBackward(event) ||\n        Hotkeys.isDeleteLineForward(event) ||\n        Hotkeys.isDeleteWordBackward(event) ||\n        Hotkeys.isDeleteWordForward(event) ||\n        Hotkeys.isItalic(event) ||\n        Hotkeys.isRedo(event) ||\n        Hotkeys.isSplitBlock(event) ||\n        Hotkeys.isTransposeCharacter(event) ||\n        Hotkeys.isUndo(event))\n    ) {\n      event.preventDefault()\n    }\n\n    debug('onKeyDown', { event })\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onPaste(event, change, editor) {\n    if (editor.props.readOnly) return true\n\n    // Prevent defaults so the DOM state isn't corrupted.\n    event.preventDefault()\n\n    debug('onPaste', { event })\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onSelect(event, change, editor) {\n    if (isCopying) return true\n    if (isComposing) return true\n    if (editor.props.readOnly) return true\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    debug('onSelect', { event })\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onChange,\n    onCompositionEnd,\n    onCompositionStart,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragEnter,\n    onDragExit,\n    onDragLeave,\n    onDragOver,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default BeforePlugin\n","/**\n * Noop.\n *\n * @return {Void}\n */\n\nfunction noop() {}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default noop\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport warning from 'slate-dev-warning'\nimport { Schema, Stack } from 'slate'\nimport memoizeOne from 'memoize-one'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport PLUGINS_PROPS from '../constants/plugin-props'\nimport AfterPlugin from '../plugins/after'\nimport BeforePlugin from '../plugins/before'\nimport noop from '../utils/noop'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nclass Editor extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool,\n    autoFocus: Types.bool,\n    className: Types.string,\n    onChange: Types.func,\n    placeholder: Types.any,\n    plugins: Types.array,\n    readOnly: Types.bool,\n    role: Types.string,\n    schema: Types.object,\n    spellCheck: Types.bool,\n    style: Types.object,\n    tabIndex: Types.number,\n    value: SlateTypes.value.isRequired,\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    autoFocus: false,\n    autoCorrect: true,\n    onChange: noop,\n    plugins: [],\n    readOnly: false,\n    schema: {},\n    spellCheck: true,\n  }\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n  state = {}\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    change: null,\n    isChanging: false,\n    operationsSize: null,\n    plugins: null,\n    resolves: 0,\n    updates: 0,\n    value: null,\n  }\n\n  /**\n   * Create a set of bound event handlers.\n   *\n   * @type {Object}\n   */\n\n  handlers = EVENT_HANDLERS.reduce((obj, handler) => {\n    obj[handler] = event => this.onEvent(handler, event)\n    return obj\n  }, {})\n\n  /**\n   * When the component first mounts, flush any temporary changes, and then,\n   * focus the editor if `autoFocus` is set.\n   */\n\n  componentDidMount() {\n    this.tmp.updates++\n\n    const { autoFocus } = this.props\n    const { change } = this.tmp\n\n    if (autoFocus) {\n      if (change) {\n        change.focus()\n      } else {\n        this.focus()\n      }\n    }\n\n    if (change) {\n      this.onChange(change)\n    }\n  }\n\n  /**\n   * When the component updates, flush any temporary change.\n   */\n\n  componentDidUpdate(prevProps) {\n    this.tmp.updates++\n\n    const { change, resolves, updates } = this.tmp\n\n    // If we've resolved a few times already, and it's exactly in line with\n    // the updates, then warn the user that they may be doing something wrong.\n    warning(\n      resolves < 5 || resolves !== updates,\n      'A Slate <Editor> component is re-resolving `props.plugins` or `props.schema` on each update, which leads to poor performance. This is often due to passing in a new `schema` or `plugins` prop with each render by declaring them inline in your render function. Do not do this!'\n    )\n\n    if (change) {\n      this.onChange(change)\n    }\n  }\n\n  /**\n   * Render the editor.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    debug('render', this)\n    const props = { ...this.props }\n    const tree = this.stack.render('renderEditor', props, this)\n    return tree\n  }\n\n  /**\n   * Get the editor's current plugins.\n   *\n   * @return {Array}\n   */\n\n  get plugins() {\n    const plugins = this.resolvePlugins(this.props.plugins, this.props.schema)\n    return plugins\n  }\n\n  /**\n   * Get the editor's current schema.\n   *\n   * @return {Schema}\n   */\n\n  get schema() {\n    const schema = this.resolveSchema(this.plugins)\n    return schema\n  }\n\n  /**\n   * Get the editor's current stack.\n   *\n   * @return {Stack}\n   */\n\n  get stack() {\n    const stack = this.resolveStack(this.plugins)\n    return stack\n  }\n\n  /**\n   * Get the editor's current value.\n   *\n   * @return {Value}\n   */\n\n  get value() {\n    // If the current `plugins` and `value` are the same as the last seen ones\n    // that were saved in `tmp`, don't re-resolve because that will trigger\n    // extra `onChange` runs.\n    if (\n      this.plugins === this.tmp.plugins &&\n      this.props.value === this.tmp.value\n    ) {\n      return this.tmp.value\n    }\n\n    const value = this.resolveValue(this.plugins, this.props.value)\n    return value\n  }\n\n  /**\n   * Perform a change on the editor, passing `...args` to `change.call`.\n   *\n   * @param {Mixed} ...args\n   */\n\n  change = (...args) => {\n    if (this.tmp.isChanging) {\n      warning(\n        false,\n        \"The `editor.change` method was called from within an existing `editor.change` callback. This is not allowed, and often due to calling `editor.change` directly from a plugin's event handler which is unnecessary.\"\n      )\n\n      return\n    }\n\n    const change = this.value.change()\n\n    try {\n      this.tmp.isChanging = true\n      change.call(...args)\n    } catch (error) {\n      throw error\n    } finally {\n      this.tmp.isChanging = false\n    }\n\n    this.onChange(change)\n  }\n\n  /**\n   * Programmatically blur the editor.\n   */\n\n  blur = () => {\n    this.change(c => c.blur())\n  }\n\n  /**\n   * Programmatically focus the editor.\n   */\n\n  focus = () => {\n    this.change(c => c.focus())\n  }\n\n  /**\n   * On change.\n   *\n   * @param {Change} change\n   */\n\n  onChange = change => {\n    // If the change doesn't define any operations to apply, abort.\n    if (change.operations.size === 0) {\n      return\n    }\n\n    debug('onChange', { change })\n    change = this.resolveChange(this.plugins, change, change.operations.size)\n\n    // Store a reference to the last `value` and `plugins` that were seen by the\n    // editor, so we can know whether to normalize a new unknown value if one\n    // is passed in via `this.props`.\n    this.tmp.value = change.value\n    this.tmp.plugins = this.plugins\n\n    // Remove the temporary `change`, since it's being flushed.\n    delete this.tmp.change\n    delete this.tmp.operationsSize\n\n    this.props.onChange(change)\n  }\n\n  /**\n   * On event.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  onEvent = (handler, event) => {\n    this.change(change => {\n      this.stack.run(handler, event, change, this)\n    })\n  }\n\n  /**\n   * Resolve a change from the current `plugins`, a potential `change` and its\n   * current operations `size`.\n   *\n   * @param {Array} plugins\n   * @param {Change} change\n   * @param {Number} size\n   */\n\n  resolveChange = memoizeOne((plugins, change, size) => {\n    const stack = this.resolveStack(plugins)\n    stack.run('onChange', change, this)\n    return change\n  })\n\n  /**\n   * Resolve a set of plugins from potential `plugins` and a `schema`.\n   *\n   * In addition to the plugins provided in props, this will initialize three\n   * other plugins:\n   *\n   * - The top-level editor plugin, which allows for top-level handlers, etc.\n   * - The two \"core\" plugins, one before all the other and one after.\n   *\n   * @param {Array|Void} plugins\n   * @param {Schema|Object|Void} schema\n   * @return {Array}\n   */\n\n  resolvePlugins = memoizeOne((plugins = [], schema = {}) => {\n    debug('resolvePlugins', { plugins, schema })\n    this.tmp.resolves++\n\n    const beforePlugin = BeforePlugin()\n    const afterPlugin = AfterPlugin()\n    const editorPlugin = { schema }\n\n    for (const prop of PLUGINS_PROPS) {\n      // Skip `onChange` because the editor's `onChange` is special.\n      if (prop == 'onChange') continue\n\n      // Skip `schema` because it can't be proxied easily, so it must be passed\n      // in as an argument to this function instead.\n      if (prop == 'schema') continue\n\n      // Define a function that will just proxies into `props`.\n      editorPlugin[prop] = (...args) => {\n        return this.props[prop] && this.props[prop](...args)\n      }\n    }\n\n    return [beforePlugin, editorPlugin, ...plugins, afterPlugin]\n  })\n\n  /**\n   * Resolve a schema from the current `plugins`.\n   *\n   * @param {Array} plugins\n   * @return {Schema}\n   */\n\n  resolveSchema = memoizeOne(plugins => {\n    debug('resolveSchema', { plugins })\n    const schema = Schema.create({ plugins })\n    return schema\n  })\n\n  /**\n   * Resolve a stack from the current `plugins`.\n   *\n   * @param {Array} plugins\n   * @return {Stack}\n   */\n\n  resolveStack = memoizeOne(plugins => {\n    debug('resolveStack', { plugins })\n    const stack = Stack.create({ plugins })\n    return stack\n  })\n\n  /**\n   * Resolve a value from the current `plugins` and a potential `value`.\n   *\n   * @param {Array} plugins\n   * @param {Value} value\n   * @return {Change}\n   */\n\n  resolveValue = memoizeOne((plugins, value) => {\n    debug('resolveValue', { plugins, value })\n    let change = value.change()\n    change = this.resolveChange(plugins, change, change.operations.size)\n\n    // Store the change and it's operations count so that it can be flushed once\n    // the component next updates.\n    this.tmp.change = change\n    this.tmp.operationsSize = change.operations.size\n\n    return change.value\n  })\n}\n\n/**\n * Mix in the prop types for the event handlers.\n */\n\nfor (const prop of EVENT_HANDLERS) {\n  Editor.propTypes[prop] = Types.func\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Editor\n","import Editor from './components/editor'\nimport cloneFragment from './utils/clone-fragment'\nimport findDOMNode from './utils/find-dom-node'\nimport findDOMRange from './utils/find-dom-range'\nimport findNode from './utils/find-node'\nimport findRange from './utils/find-range'\nimport getEventRange from './utils/get-event-range'\nimport getEventTransfer from './utils/get-event-transfer'\nimport setEventTransfer from './utils/set-event-transfer'\nimport AfterPlugin from './plugins/after'\nimport BeforePlugin from './plugins/before'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMRange,\n  findNode,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  AfterPlugin,\n  BeforePlugin,\n}\n\nexport default {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMRange,\n  findNode,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  AfterPlugin,\n  BeforePlugin,\n}\n"],"names":["EVENT_HANDLERS","PLUGIN_PROPS","PARSER","parse","string","matches","exec","Error","original","key","index","parseInt","stringify","object","debug","Debug","Leaf","props","marks","text","parent","node","offsetKey","OffsetKey","renderMarks","offset","editor","stack","leaf","renderText","attributes","reduce","children","mark","element","find","block","leaves","value","schema","isVoid","nodes","last","lastText","getLastText","lastChar","charAt","length","isLastText","isLastLeaf","size","React","Component","propTypes","SlateTypes","isRequired","Types","number","message","args","Text","decorations","style","document","decs","filter","start","d","end","path","assertPath","PathUtils","compare","getLeaves","map","i","child","renderLeaf","ImmutableTypes","list","defaultProps","shouldComponentUpdate","n","nextProps","p","pLast","nLast","equals","Void","readOnly","Tag","spacer","content","any","bool","type","id","getFirstText","getChildrenDecorations","activeDecorations","Set","asMutable","childrenDecorations","forEach","item","isRangeStart","add","decoration","isRangeEnd","remove","push","toList","orderChildDecorations","isEmpty","toArray","keyOrders","globalOrder","forEachDescendant","childNodes","endPoints","startKeyOrder","containingChildOrder","undefined","getContainingChildOrder","endKeyOrder","sort","a","b","order","nextChildIndex","findIndex","containingChild","Node","shouldUpdate","isSelected","isFocused","selection","indexes","getSelectionIndexes","concat","getDecorations","isChildSelected","renderNode","first","direction","getTextDirection","dir","placeholder","cloneElement","findDOMNode","win","window","isNode","el","querySelector","findDOMPoint","point","iterator","createNodeIterator","NodeFilter","SHOW_TEXT","FILTER_ACCEPT","nextNode","textContent","o","findDOMRange","range","anchor","focus","isBackward","isCollapsed","domAnchor","domFocus","r","createRange","setStart","setEnd","ZERO_WIDTH_ATTRIBUTE","ZERO_WIDTH_SELECTOR","OFFSET_KEY_ATTRIBUTE","RANGE_SELECTOR","TEXT_SELECTOR","VOID_SELECTOR","findPoint","nativeNode","nativeOffset","normalizeNodeAndOffset","nearestNode","nearestOffset","getWindow","parentNode","rangeNode","closest","textNode","toString","voidNode","hasAttribute","getAttribute","hasDescendant","createPoint","nodeType","isLast","getEditableChild","triedForward","triedBackward","findRange","native","anchorNode","startContainer","Range","StaticRange","startOffset","endContainer","endOffset","anchorOffset","focusNode","focusOffset","IS_IE","IS_EDGE","OVERFLOWS","IS_IOS_11","IS_IOS","navigator","userAgent","match","findScrollContainer","scroller","getComputedStyle","overflowY","includes","body","scrollToSelection","isWindow","documentElement","backward","getRangeAt","cloneRange","collapse","cursorRect","getBoundingClientRect","IS_SAFARI","collapsed","top","height","getClientRects","width","yOffset","xOffset","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","innerWidth","innerHeight","pageYOffset","pageXOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","left","cursorTop","cursorLeft","x","y","scrollTo","removeAllRanges","doc","createTextRange","select","FIREFOX_NODE_TYPE_ACCESS_ERROR","Content","tmp","handlers","obj","handler","onEvent","event","updateSelection","getSelection","rangeCount","isBlurred","isInEditor","blur","isUnset","current","isUpdatingSelection","setBaseAndExtent","addRange","IS_FIREFOX","ref","target","err","test","allowEdit","isContentEditable","onNativeSelectionChange","throttle","activeElement","onSelect","addEventListener","HAS_INPUT_EVENTS_LEVEL_2","onBeforeInput","removeEventListener","toRange","targetEditorNode","className","tabIndex","role","tagName","spellCheck","Container","WebkitUserModify","autoCorrect","func","TRANSFER_TYPES","FRAGMENT","HTML","TEXT","cloneFragment","fragment","callback","startVoid","getClosestVoid","endVoid","encoded","Base64","serializeNode","contents","cloneContents","attach","trim","setEndAfter","firstChild","slice","call","querySelectorAll","isNewline","zw","span","createElement","whiteSpace","appendChild","setAttribute","valFromSelection","Value","create","plainText","Plain","serialize","div","clipboardData","setData","preventDefault","innerHTML","position","selectAllChildren","requestAnimationFrame","removeChild","findNode","getNode","getEventRange","nativeEvent","rect","isPrevious","previousText","getPreviousText","moveToEndOfNode","nextText","getNextText","moveToStartOfNode","caretRangeFromPoint","caretPositionFromPoint","offsetNode","moveToPoint","error","NODE","RICH","FRAGMENT_MATCHER","getEventTransfer","transfer","dataTransfer","getType","html","rich","files","indexOf","full","embeddedTypes","getEmbeddedTypes","deserializeNode","items","Array","from","kind","getAsFile","exists","data","getTransferType","prefix","substring","JSON","types","getData","setEventTransfer","mime","toUpperCase","e","AfterPlugin","isDraggingInternally","change","isSynthetic","insertText","getTargetRanges","targetRange","inputType","deleteAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","deleteLineBackwardAtRange","deleteLineForwardAtRange","hasVoidParent","moveToStartOfNextText","splitBlockAtRange","insertTextAtRange","onBlur","onClick","ancestors","getAncestors","some","onCopy","onCut","endBlock","endInline","isVoidBlock","isVoidInline","c","removeNodeByKey","delete","onDragEnd","onDragOver","onDragStart","selectionIncludesNode","blocks","moveToRangeOfNode","onDrop","moveForward","split","line","splitBlock","insertFragment","dispatchEvent","MouseEvent","onInput","getDescendant","getClosestBlock","lastLeaf","delta","corrected","moveToEnd","entire","moveAnchorTo","moveFocusTo","resolveRange","onKeyDown","Hotkeys","isSplitBlock","isDeleteBackward","deleteCharBackward","isDeleteForward","deleteCharForward","isDeleteLineBackward","deleteLineBackward","isDeleteLineForward","deleteLineForward","isDeleteWordBackward","deleteWordBackward","isDeleteWordForward","deleteWordForward","isRedo","redo","isUndo","undo","isMoveLineBackward","moveToStartOfBlock","isMoveLineForward","moveToEndOfBlock","isExtendLineBackward","moveFocusToStartOfBlock","isExtendLineForward","moveFocusToEndOfBlock","isMoveBackward","startText","isPreviousInVoid","moveBackward","isMoveForward","isNextInVoid","isExtendBackward","moveFocusBackward","isExtendForward","moveFocusForward","onPaste","startBlock","defaultBlock","defaultMarks","getInsertMarksAtRange","frag","deserialize","anchorText","focusText","anchorInline","getClosestInline","focusInline","focusBlock","anchorBlock","setFocus","setOffset","next","createSelection","setIsFocused","set","renderEditor","renderPlaceholder","state","isComposing","isTextList","getBlocks","BeforePlugin","compositionCount","isCopying","isDragging","relatedTarget","contains","onChange","withoutSaving","setValue","normalize","onCompositionEnd","setState","onCompositionStart","onDragEnter","onDragExit","onDragLeave","dropEffect","onFocus","isCompose","isBold","isItalic","isTransposeCharacter","noop","Editor","updates","autoFocus","prevProps","resolves","tree","render","plugins","resolvePlugins","resolveSchema","resolveStack","resolveValue","array","isChanging","operations","resolveChange","operationsSize","run","memoizeOne","beforePlugin","afterPlugin","editorPlugin","prop","PLUGINS_PROPS","Schema","Stack"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;;;;;AAMA,IAAMA,iBAAiB,CACrB,eADqB,EAErB,QAFqB,EAGrB,SAHqB,EAIrB,eAJqB,EAKrB,kBALqB,EAMrB,oBANqB,EAOrB,QAPqB,EAQrB,OARqB,EASrB,WATqB,EAUrB,aAVqB,EAWrB,YAXqB,EAYrB,aAZqB,EAarB,YAbqB,EAcrB,aAdqB,EAerB,QAfqB,EAgBrB,SAhBqB,EAiBrB,SAjBqB,EAkBrB,WAlBqB,EAmBrB,SAnBqB,EAoBrB,SApBqB,EAqBrB,UArBqB,CAAvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;;;;;;AAMA,IAAMC,2CACDD,cADC,IAEJ,cAFI,EAGJ,UAHI,EAIJ,cAJI,EAKJ,YALI,EAMJ,YANI,EAOJ,mBAPI,EAQJ,cARI,EASJ,QATI,EAUJ,cAVI,EAAN;;ACRA;;;;;;AAMA,IAAME,SAAS,uBAAf;;;;;;;;;AASA,SAASC,KAAT,CAAeC,MAAf,EAAuB;MACfC,UAAUH,OAAOI,IAAP,CAAYF,MAAZ,CAAhB;;MAEI,CAACC,OAAL,EAAc;UACN,IAAIE,KAAJ,kCAAwCH,MAAxC,SAAN;;;+BAG6BC,OAPV;MAOdG,QAPc;MAOJC,GAPI;MAOCC,KAPD;;;SAQd;YAAA;WAEEC,SAASD,KAAT,EAAgB,EAAhB;GAFT;;;;;;;;;;;;AAeF,SAASE,SAAT,CAAmBC,MAAnB,EAA2B;SACfA,OAAOJ,GAAjB,SAAwBI,OAAOH,KAA/B;;;;;;;;;AASF,gBAAe;cAAA;;CAAf;;ACzCA;;;;;;AAMA,IAAMI,QAAQC,MAAM,cAAN,CAAd;;;;;;;;IAQMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAqCkBC,OAAO;;UAGzBA,MAAMP,KAAN,IAAe,KAAKO,KAAL,CAAWP,KAA1B,IACAO,MAAMC,KAAN,IAAe,KAAKD,KAAL,CAAWC,KAD1B,IAEAD,MAAME,IAAN,IAAc,KAAKF,KAAL,CAAWE,IAFzB,IAGAF,MAAMG,MAAN,IAAgB,KAAKH,KAAL,CAAWG,MAJ7B,EAKE;eACO,IAAP;;;;aAIK,KAAP;;;;;;;;;;;6BASO;WACFN,KAAL,CAAW,QAAX,EAAqB,IAArB;;mBAEwB,KAAKG,KAHtB;UAGCI,IAHD,UAGCA,IAHD;UAGOX,KAHP,UAGOA,KAHP;;UAIDY,YAAYC,UAAUX,SAAV,CAAoB;aAC/BS,KAAKZ,GAD0B;;OAApB,CAAlB;;aAKO;;UAAM,mBAAiBa,SAAvB;aAAwCE,WAAL;OAA1C;;;;;;;;;;;kCASY;oBACkC,KAAKP,KADvC;UACJC,KADI,WACJA,KADI;UACGG,IADH,WACGA,IADH;UACSI,MADT,WACSA,MADT;UACiBN,IADjB,WACiBA,IADjB;UACuBO,MADvB,WACuBA,MADvB;UAEJC,KAFI,GAEMD,MAFN,CAEJC,KAFI;;UAGNC,OAAO,KAAKC,UAAL,EAAb;UACMC,aAAa;2BACE;OADrB;;aAIOZ,MAAMa,MAAN,CAAa,UAACC,QAAD,EAAWC,IAAX,EAAoB;YAChChB,QAAQ;wBAAA;oBAAA;sBAAA;oBAAA;wBAAA;oBAAA;4BAAA;;SAAd;YAUMiB,UAAUP,MAAMQ,IAAN,CAAW,YAAX,EAAyBlB,KAAzB,CAAhB;eACOiB,WAAWF,QAAlB;OAZK,EAaJJ,IAbI,CAAP;;;;;;;;;;;iCAsBW;oBACkD,KAAKX,KADvD;UACHmB,KADG,WACHA,KADG;UACIf,IADJ,WACIA,IADJ;UACUK,MADV,WACUA,MADV;UACkBN,MADlB,WACkBA,MADlB;UAC0BD,IAD1B,WAC0BA,IAD1B;UACgCT,KADhC,WACgCA,KADhC;UACuC2B,MADvC,WACuCA,MADvC;UAEHC,KAFG,GAEOZ,MAFP,CAEHY,KAFG;UAGHC,MAHG,GAGQD,KAHR,CAGHC,MAHG;;;;;UAOPA,OAAOC,MAAP,CAAcpB,MAAd,CAAJ,EAA2B;eAClB;;YAAM,yBAAsB,GAA5B;;SAAP;;;;;;UAOAD,SAAS,EAAT,IACAC,OAAOP,MAAP,KAAkB,OADlB,IAEAO,OAAOD,IAAP,KAAgB,EAFhB,IAGAC,OAAOqB,KAAP,CAAaC,IAAb,OAAwBrB,IAJ1B,EAKE;eACO;;YAAM,yBAAsB,GAA5B;;SAAP;;;;;;UAMEF,SAAS,EAAb,EAAiB;eACR;;YAAM,yBAAsB,GAA5B;;SAAP;;;;;UAKIwB,WAAWP,MAAMQ,WAAN,EAAjB;UACMC,WAAW1B,KAAK2B,MAAL,CAAY3B,KAAK4B,MAAL,GAAc,CAA1B,CAAjB;UACMC,aAAa3B,SAASsB,QAA5B;UACMM,aAAavC,UAAU2B,OAAOa,IAAP,GAAc,CAA3C;UACIF,cAAcC,UAAd,IAA4BJ,aAAa,IAA7C,EAAmD,OAAU1B,IAAV;;;aAG5CA,IAAP;;;;EAjJegC,MAAMC;;;;;;;;AAAnBpC,KAOGqC,YAAY;SACVC,WAAWlB,KAAX,CAAiBmB,UADP;UAETC,MAAM3C,MAAN,CAAa0C,UAFJ;SAGVC,MAAMC,MAAN,CAAaF,UAHH;UAITD,WAAWjB,MAAX,CAAkBkB,UAJT;SAKVD,WAAWpC,KAAX,CAAiBqC,UALP;QAMXD,WAAWjC,IAAX,CAAgBkC,UANL;UAOTC,MAAMC,MAAN,CAAaF,UAPJ;UAQTD,WAAWjC,IAAX,CAAgBkC,UARP;QASXC,MAAMpD,MAAN,CAAamD,UATF;;;;;OAmBnBzC,QAAQ,UAAC4C,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;4BACtBD,OAAN,EAAkB,OAAKzC,KAAL,CAAWI,IAAX,CAAgBZ,GAAlC,SAAyC,OAAKQ,KAAL,CAAWP,KAApD,SAAgEiD,IAAhE;;;;ACvCJ;;;;;;AAMA,IAAM7C,UAAQC,MAAM,YAAN,CAAd;;;;;;;;IAQM6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BA+EK;;;WACF9C,KAAL,CAAW,QAAX,EAAqB,IAArB;;mBAE6C,KAAKG,KAH3C;UAGC4C,WAHD,UAGCA,WAHD;UAGcnC,MAHd,UAGcA,MAHd;UAGsBL,IAHtB,UAGsBA,IAHtB;UAG4ByC,KAH5B,UAG4BA,KAH5B;UAICxB,KAJD,GAIWZ,MAJX,CAICY,KAJD;UAKCyB,QALD,GAKczB,KALd,CAKCyB,QALD;UAMCtD,GAND,GAMSY,IANT,CAMCZ,GAND;;;UAQDuD,OAAOH,YAAYI,MAAZ,CAAmB,aAAK;YAC3BC,KAD2B,GACZC,CADY,CAC3BD,KAD2B;YACpBE,GADoB,GACZD,CADY,CACpBC,GADoB;;;;YAI/BF,MAAMzD,GAAN,KAAcA,GAAd,IAAqB2D,IAAI3D,GAAJ,KAAYA,GAArC,EAA0C,OAAO,IAAP;;;YAGtCyD,MAAMzD,GAAN,KAAc2D,IAAI3D,GAAtB,EAA2B,OAAO,KAAP;;;YAGrB4D,OAAON,SAASO,UAAT,CAAoB7D,GAApB,CAAb;YACI8D,UAAUC,OAAV,CAAkBH,IAAlB,EAAwBH,MAAMG,IAA9B,MAAwC,CAAC,CAA7C,EAAgD,OAAO,KAAP;;;YAG5CE,UAAUC,OAAV,CAAkBH,IAAlB,EAAwBD,IAAIC,IAA5B,MAAsC,CAA1C,EAA6C,OAAO,KAAP;;;eAGtC,IAAP;OAjBW,CAAb;;;UAqBMhC,SAAS2B,KAAKd,IAAL,KAAc,CAAd,GAAkB7B,KAAKoD,SAAL,EAAlB,GAAqCpD,KAAKoD,SAAL,CAAeT,IAAf,CAApD;UACIvC,SAAS,CAAb;;UAEMO,WAAWK,OAAOqC,GAAP,CAAW,UAAC9C,IAAD,EAAO+C,CAAP,EAAa;YACjCC,QAAQ,OAAKC,UAAL,CAAgBxC,MAAhB,EAAwBT,IAAxB,EAA8B+C,CAA9B,EAAiClD,MAAjC,CAAd;kBACUG,KAAKT,IAAL,CAAU4B,MAApB;eACO6B,KAAP;OAHe,CAAjB;;aAOE;;UAAM,YAAUnE,GAAhB,EAAqB,OAAOqD,KAA5B;;OADF;;;;;;;;;;;;;;;EArHeX,MAAMC;;;;;;;;AAAnBQ,OAOGP,YAAY;SACVC,WAAWlB,KADD;eAEJ0C,eAAeC,IAAf,CAAoBxB,UAFhB;UAGTC,MAAM3C,MAAN,CAAa0C,UAHJ;QAIXD,WAAWjC,IAAX,CAAgBkC,UAJL;UAKTD,WAAWjC,IAAX,CAAgBkC,UALP;SAMVC,MAAM3C,MANI;AAPf+C,OAsBGoB,eAAe;SACb,IADa;;;;;OAWtBlE,QAAQ,UAAC4C,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;QACpBtC,IADoB,GACX,OAAKJ,KADM,CACpBI,IADoB;QAEpBZ,GAFoB,GAEZY,IAFY,CAEpBZ,GAFoB;;8BAGtBiD,OAAN,EAAkBjD,GAAlB,qBAAmCkD,IAAnC;;;OAWFsB,wBAAwB,qBAAa;QAC3BhE,KAD2B,UAC3BA,KAD2B;;QAE7BiE,IAAIC,SAAV;QACMC,IAAInE,KAAV;;;;;;QAMIiE,EAAE7D,IAAF,IAAU+D,EAAE/D,IAAhB,EAAsB,OAAO,IAAP;;;;QAIlB6D,EAAE9D,MAAF,CAASP,MAAT,IAAmB,OAAvB,EAAgC;UACxBwE,QAAQD,EAAEhE,MAAF,CAASqB,KAAT,CAAeC,IAAf,EAAd;UACM4C,QAAQJ,EAAE9D,MAAF,CAASqB,KAAT,CAAeC,IAAf,EAAd;UACI0C,EAAE/D,IAAF,IAAUgE,KAAV,IAAmBH,EAAE7D,IAAF,IAAUiE,KAAjC,EAAwC,OAAO,IAAP;;;;QAItC,CAACJ,EAAErB,WAAF,CAAc0B,MAAd,CAAqBH,EAAEvB,WAAvB,CAAL,EAA0C,OAAO,IAAP;;;WAGnC,KAAP;;;OAgEFgB,aAAa,UAACxC,MAAD,EAAST,IAAT,EAAelB,KAAf,EAAsBe,MAAtB,EAAiC;kBACJ,OAAKR,KADD;QACpCmB,KADoC,WACpCA,KADoC;QAC7Bf,IAD6B,WAC7BA,IAD6B;QACvBD,MADuB,WACvBA,MADuB;QACfM,MADe,WACfA,MADe;QAEpCP,IAFoC,GAEpBS,IAFoB,CAEpCT,IAFoC;QAE9BD,KAF8B,GAEpBU,IAFoB,CAE9BV,KAF8B;;;WAK1C,oBAAC,IAAD;WACUG,KAAKZ,GAAb,SAAoBC,KADtB;aAES0B,KAFT;cAGUV,MAHV;aAIShB,KAJT;aAKSQ,KALT;YAMQG,IANR;cAOUI,MAPV;cAQUL,MARV;cASUiB,MATV;YAUQlB;MAXV;;;;AC1JJ;;;;;;AAMA,IAAML,UAAQC,MAAM,YAAN,CAAd;;;;;;;;IAQMyE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAoCK;UACCvE,KADD,GACW,IADX,CACCA,KADD;UAECe,QAFD,GAE8Bf,KAF9B,CAECe,QAFD;UAEWX,IAFX,GAE8BJ,KAF9B,CAEWI,IAFX;UAEiBoE,QAFjB,GAE8BxE,KAF9B,CAEiBwE,QAFjB;;UAGDC,MAAMrE,KAAKR,MAAL,IAAe,OAAf,GAAyB,KAAzB,GAAiC,MAA7C;UACMiD,QAAQ;gBACJ,GADI;eAEL,aAFK;iBAGH,MAHG;kBAIF;OAJZ;;UAOM6B,SACJ;WAAA;UAAK,yBAAL,EAAuB,OAAO7B,KAA9B;aACQjC,UAAL;OAFL;;UAMM+D,UACJ;WAAA;UAAK,iBAAiBH,WAAW,IAAX,GAAkB,KAAxC;;OADF;;WAIK3E,KAAL,CAAW,QAAX,EAAqB,EAAEG,YAAF,EAArB;;aAGE;WAAA;;iCAAA;sBAEYI,KAAKZ,GAFjB;2BAGmBgF,YAAYpE,KAAKR,MAAL,IAAe,OAA3B,GAAqC,IAArC,GAA4C;;mBAEjD,IAAX,GAAkB8E,MALrB;;OADF;;;;;;;;;;;;;;;;EA3DexC,MAAMC;;;;;;;;AAAnBoC,KAOGnC,YAAY;SACVC,WAAWlB,KADD;YAEPoB,MAAMqC,GAAN,CAAUtC,UAFH;UAGTC,MAAM3C,MAAN,CAAa0C,UAHJ;QAIXD,WAAWjC,IAAX,CAAgBkC,UAJL;UAKTD,WAAWjC,IAAX,CAAgBkC,UALP;YAMPC,MAAMsC,IAAN,CAAWvC,UANJ;;;;;OAgBnBzC,QAAQ,UAAC4C,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;QACpBtC,IADoB,GACX,OAAKJ,KADM,CACpBI,IADoB;QAEpBZ,GAFoB,GAENY,IAFM,CAEpBZ,GAFoB;QAEfsF,IAFe,GAEN1E,IAFM,CAEf0E,IAFe;;QAGtBC,KAAQvF,GAAR,UAAgBsF,IAAhB,MAAN;8BACMrC,OAAN,OAAkBsC,EAAlB,SAA2BrC,IAA3B;;;OAuDF9B,aAAa,YAAM;iBACsC,OAAKZ,KAD3C;QACTmB,KADS,UACTA,KADS;QACFyB,WADE,UACFA,WADE;QACWxC,IADX,UACWA,IADX;QACiBoE,QADjB,UACiBA,QADjB;QAC2B/D,MAD3B,UAC2BA,MAD3B;;QAEXkD,QAAQvD,KAAK4E,YAAL,EAAd;WAEE,oBAACrC,MAAD;aACSvC,KAAKR,MAAL,IAAe,OAAf,GAAyBQ,IAAzB,GAAgCe,KADzC;mBAEeyB,WAFf;cAGUnC,MAHV;WAIOkD,MAAMnE,GAJb;YAKQmE,KALR;cAMUvD,IANV;gBAOYoE;MARd;;;;ACxGJ;;;;;;;;AAQA,SAASS,sBAAT,CAAgC7E,IAAhC,EAAsCwC,WAAtC,EAAmD;MAC3CsC,oBAAoBC,MAAMC,SAAN,EAA1B;MACMC,sBAAsB,EAA5B;;wBAEsBjF,IAAtB,EAA4BwC,WAA5B,EAAyC0C,OAAzC,CAAiD,gBAAQ;QACnDC,KAAKC,YAAT,EAAuB;;wBAEHC,GAAlB,CAAsBF,KAAKG,UAA3B;KAFF,MAGO,IAAIH,KAAKI,UAAT,EAAqB;;wBAERC,MAAlB,CAAyBL,KAAKG,UAA9B;KAFK,MAGA;;0BAEeG,IAApB,CAAyBX,kBAAkBY,MAAlB,EAAzB;;GATJ;;SAaOT,mBAAP;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BF,SAASU,qBAAT,CAA+B3F,IAA/B,EAAqCwC,WAArC,EAAkD;MAC5CA,YAAYoD,OAAZ,EAAJ,EAA2B;WAClB5F,KAAKoB,KAAL,CAAWyE,OAAX,GAAqBxC,GAArB,CAAyB,UAACE,KAAD,EAAQlE,KAAR;aAAmB;oBAAA;;OAAnB;KAAzB,CAAP;;;;MAOIyG,+BAAe9F,KAAKZ,GAApB,EAA0B,CAA1B,CAAN;MACI2G,cAAc,CAAlB;;OAEKC,iBAAL,CAAuB,iBAAS;cACpBzC,MAAMnE,GAAhB,IAAuB2G,WAAvB;kBACcA,cAAc,CAA5B;GAFF;;MAKME,aAAajG,KAAKoB,KAAL,CAAWyE,OAAX,EAAnB;;MAEMK,YAAYD,WAAW5C,GAAX,CAAe,UAACE,KAAD,EAAQlE,KAAR;WAAmB;kBAAA;kBAAA;aAG3CyG,UAAUvC,MAAMnE,GAAhB;KAHwB;GAAf,CAAlB;;cAMY8F,OAAZ,CAAoB,sBAAc;;;;QAI1BiB,gBAAgBL,UAAUR,WAAWzC,KAAX,CAAiBzD,GAA3B,CAAtB;QACMgH,uBACJD,kBAAkBE,SAAlB,GACI,CADJ,GAEIC,wBAAwBL,UAAxB,EAAoCH,SAApC,EAA+CK,aAA/C,CAHN;;cAKUV,IAAV,CAAe;oBACC,IADD;aAENW,uBAAuB,GAFjB;;KAAf;;;QAOMG,cAAc,CAACT,UAAUR,WAAWvC,GAAX,CAAe3D,GAAzB,KAAiC2G,WAAlC,IAAiD,GAArE;;cAEUN,IAAV,CAAe;kBACD,IADC;aAENc,WAFM;;KAAf;GAnBF;;SA0BOL,UAAUM,IAAV,CAAe,UAACC,CAAD,EAAIC,CAAJ;WAAWD,EAAEE,KAAF,GAAUD,EAAEC,KAAZ,GAAoB,CAApB,GAAwB,CAAC,CAApC;GAAf,CAAP;;;;;;;AAOF,SAASL,uBAAT,CAAiC3F,QAAjC,EAA2CmF,SAA3C,EAAsDa,KAAtD,EAA6D;;MAErDC,iBAAiBjG,SAASkG,SAAT,CACrB;WAASF,QAAQb,UAAUvC,MAAMnE,GAAhB,CAAjB;GADqB,CAAvB;;MAIIwH,kBAAkB,CAAtB,EAAyB;WAChB,CAAP;;;MAGIE,kBAAkBnG,SAASiG,iBAAiB,CAA1B,CAAxB;SACOd,UAAUgB,gBAAgB1H,GAA1B,CAAP;;;AC/GF;;;;;;AAMA,IAAMK,UAAQC,MAAM,YAAN,CAAd;;;;;;;;IAQMqH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAuCkBjD,WAAW;UACvBlE,KADuB,GACb,IADa,CACvBA,KADuB;UAEvBU,KAFuB,GAEbV,MAAMS,MAFO,CAEvBC,KAFuB;;UAGzB0G,eAAe1G,MAAMQ,IAAN,CACnB,2BADmB,EAEnBlB,KAFmB,EAGnBkE,SAHmB,CAArB;UAKMD,IAAIC,SAAV;UACMC,IAAInE,KAAV;;;;;UAKIoH,gBAAgB,IAApB,EAA0B;YACpBA,YAAJ,EAAkB;iBACT,IAAP;;;gBAIAA,iBAAiB,KADnB,EAEE,8LAFF;;;;;UAQEnD,EAAEO,QAAF,IAAcL,EAAEK,QAApB,EAA8B,OAAO,IAAP;;;;;;UAM1BP,EAAE7D,IAAF,IAAU+D,EAAE/D,IAAhB,EAAsB,OAAO,IAAP;;;;;;;UAOlB6D,EAAEoD,UAAF,IAAgBlD,EAAEkD,UAAtB,EAAkC,OAAO,IAAP;UAC9BpD,EAAEqD,SAAF,IAAenD,EAAEmD,SAArB,EAAgC,OAAO,IAAP;;;UAG5B,CAACrD,EAAErB,WAAF,CAAc0B,MAAd,CAAqBH,EAAEvB,WAAvB,CAAL,EAA0C,OAAO,IAAP;;;aAGnC,KAAP;;;;;;;;;;;6BASO;;;WACF/C,KAAL,CAAW,QAAX,EAAqB,IAArB;mBASI,KAAKG,KAVF;UAGLS,MAHK,UAGLA,MAHK;UAIL4G,UAJK,UAILA,UAJK;UAKLC,SALK,UAKLA,SALK;UAMLlH,IANK,UAMLA,IANK;UAOLwC,WAPK,UAOLA,WAPK;UAQLzC,MARK,UAQLA,MARK;UASLqE,QATK,UASLA,QATK;UAWCnD,KAXD,GAWWZ,MAXX,CAWCY,KAXD;UAYCkG,SAZD,GAYuBlG,KAZvB,CAYCkG,SAZD;UAYYjG,MAZZ,GAYuBD,KAZvB,CAYYC,MAZZ;UAaCZ,KAbD,GAaWD,MAbX,CAaCC,KAbD;;UAcD8G,UAAUpH,KAAKqH,mBAAL,CAAyBF,SAAzB,EAAoCF,UAApC,CAAhB;UACMtE,OAAOH,YAAY8E,MAAZ,CAAmBtH,KAAKuH,cAAL,CAAoBjH,KAApB,CAAnB,CAAb;UACM2E,sBAAsBJ,uBAAuB7E,IAAvB,EAA6B2C,IAA7B,CAA5B;;UAEIhC,WAAW,EAAf;;WAEKS,KAAL,CAAW8D,OAAX,CAAmB,UAAC3B,KAAD,EAAQD,CAAR,EAAc;YACzBkE,kBAAkB,CAAC,CAACJ,OAAF,IAAaA,QAAQvE,KAAR,IAAiBS,CAA9B,IAAmCA,IAAI8D,QAAQrE,GAAvE;;iBAES0C,IAAT,CACE,OAAKgC,UAAL,CAAgBlE,KAAhB,EAAuBiE,eAAvB,EAAwCvC,oBAAoB3B,CAApB,CAAxC,CADF;OAHF;;;;UAUM7C,aAAa,EAAE,YAAYT,KAAKZ;;;;OAAtC,CAIA,IAAIY,KAAKR,MAAL,IAAe,OAAf,IAA0BQ,KAAKoB,KAAL,CAAWsG,KAAX,GAAmBlI,MAAnB,IAA6B,OAA3D,EAAoE;YAC5DmI,YAAY3H,KAAK4H,gBAAL,EAAlB;YACID,aAAa,KAAjB,EAAwBlH,WAAWoH,GAAX,GAAiB,KAAjB;;;UAGpBjI,QAAQ;aACPI,KAAKZ,GADE;sBAAA;4BAAA;8BAAA;kBAAA;sBAAA;;OAAd;;UAUI0I,cAAcxH,MAAMQ,IAAN,CAAW,mBAAX,EAAgClB,KAAhC,CAAlB;;UAEIkI,WAAJ,EAAiB;sBACDhG,MAAMiG,YAAN,CAAmBD,WAAnB,EAAgC;eACpC9H,KAAKZ,GAAb;SADY,CAAd;;oBAIY0I,WAAZ,2BAA4BnH,QAA5B;;;UAGIE,UAAUP,MAAMQ,IAAN,CAAW,YAAX,eACXlB,KADW;8BAAA;;SAAhB;;aAMOsB,OAAOC,MAAP,CAAcnB,IAAd,IACL;YAAA;aAAeJ,KAAf;;OADK,GAGLiB,OAHF;;;;;;;;;;;;;;EAhKeiB,MAAMC;;;;;;;;AAAnBgF,OAOG/E,YAAY;SACVC,WAAWlB,KADD;eAEJ0C,eAAeC,IAAf,CAAoBxB,UAFhB;UAGTC,MAAM3C,MAAN,CAAa0C,UAHJ;aAINC,MAAMsC,IAAN,CAAWvC,UAJL;cAKLC,MAAMsC,IAAN,CAAWvC,UALN;QAMXD,WAAWjC,IAAX,CAAgBkC,UANL;UAOTD,WAAWjC,IAAX,CAAgBkC,UAPP;YAQPC,MAAMsC,IAAN,CAAWvC,UARJ;;;;;OAkBnBzC,QAAQ,UAAC4C,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;QACpBtC,IADoB,GACX,OAAKJ,KADM,CACpBI,IADoB;QAEpBZ,GAFoB,GAENY,IAFM,CAEpBZ,GAFoB;QAEfsF,IAFe,GAEN1E,IAFM,CAEf0E,IAFe;;8BAGtBrC,OAAN,EAAkBjD,GAAlB,UAA0BsF,IAA1B,eAAsCpC,IAAtC;;;OAoJFmF,aAAa,UAAClE,KAAD,EAAQ0D,UAAR,EAAoBzE,WAApB,EAAoC;kBACM,OAAK5C,KADX;QACvCmB,KADuC,WACvCA,KADuC;QAChCV,MADgC,WAChCA,MADgC;QACxBL,IADwB,WACxBA,IADwB;QAClBoE,QADkB,WAClBA,QADkB;QACR8C,SADQ,WACRA,SADQ;;QAEzCnF,YAAYwB,MAAM/D,MAAN,IAAgB,MAAhB,GAAyB+C,MAAzB,GAAgCwE,MAAlD;;WAGE,oBAAC,SAAD;aACS/G,KAAKR,MAAL,IAAe,OAAf,GAAyBQ,IAAzB,GAAgCe,KADzC;mBAEeyB,WAFf;cAGUnC,MAHV;kBAIc4G,UAJd;iBAKaC,aAAaD,UAL1B;WAMO1D,MAAMnE,GANb;YAOQmE,KAPR;cAQUvD,IARV;gBASYoE;MAVd;;;;AC3MJ;;;;;;;;AAQA,SAAS4D,aAAT,CAAqB5I,GAArB,EAAwC;MAAd6I,GAAc,uEAARC,MAAQ;;MAClCnB,KAAKoB,MAAL,CAAY/I,GAAZ,CAAJ,EAAsB;UACdA,IAAIA,GAAV;;;MAGIgJ,KAAKH,IAAIvF,QAAJ,CAAa2F,aAAb,iBAAyCjJ,GAAzC,QAAX;;MAEI,CAACgJ,EAAL,EAAS;UACD,IAAIlJ,KAAJ,qCAC8BE,GAD9B,6FAAN;;;SAKKgJ,EAAP;;;ACrBF;;;;;;;;AAQA,SAASE,YAAT,CAAsBC,KAAtB,EAA2C;MAAdN,GAAc,uEAARC,MAAQ;;MACnCE,KAAKJ,cAAYO,MAAMnJ,GAAlB,EAAuB6I,GAAvB,CAAX;MACIpF,QAAQ,CAAZ;MACIgB,UAAJ;;;;MAIM2E,WAAWP,IAAIvF,QAAJ,CAAa+F,kBAAb,CACfL,EADe,EAEfM,WAAWC,SAFI,EAGf;WAAMD,WAAWE,aAAjB;GAHe,EAIf,KAJe,CAAjB;;SAOQ/E,IAAI2E,SAASK,QAAT,EAAZ,EAAkC;QACxBnH,MADwB,GACbmC,EAAEiF,WADW,CACxBpH,MADwB;;QAE1BqB,MAAMF,QAAQnB,MAApB;;QAEI6G,MAAMnI,MAAN,IAAgB2C,GAApB,EAAyB;UACjBgG,IAAIR,MAAMnI,MAAN,GAAeyC,KAAzB;aACO,EAAE7C,MAAM6D,CAAR,EAAWzD,QAAQ2I,KAAK,CAAL,GAASA,CAAT,GAAa,CAAhC,EAAP;;;YAGMhG,GAAR;;;SAGK,IAAP;;;AClCF;;;;;;;;AAQA,SAASiG,YAAT,CAAsBC,KAAtB,EAA2C;MAAdhB,GAAc,uEAARC,MAAQ;MACjCgB,MADiC,GACUD,KADV,CACjCC,MADiC;MACzBC,KADyB,GACUF,KADV,CACzBE,KADyB;MAClBC,aADkB,GACUH,KADV,CAClBG,UADkB;MACNC,WADM,GACUJ,KADV,CACNI,WADM;;MAEnCC,YAAYhB,aAAaY,MAAb,EAAqBjB,GAArB,CAAlB;MACMsB,WAAWF,cAAcC,SAAd,GAA0BhB,aAAaa,KAAb,EAAoBlB,GAApB,CAA3C;;MAEI,CAACqB,SAAD,IAAc,CAACC,QAAnB,EAA6B,OAAO,IAAP;;MAEvBC,IAAIvB,IAAIvF,QAAJ,CAAa+G,WAAb,EAAV;MACM5G,QAAQuG,gBAAaG,QAAb,GAAwBD,SAAtC;MACMvG,MAAMqG,gBAAaE,SAAb,GAAyBC,QAArC;IACEG,QAAF,CAAW7G,MAAM7C,IAAjB,EAAuB6C,MAAMzC,MAA7B;IACEuJ,MAAF,CAAS5G,IAAI/C,IAAb,EAAmB+C,IAAI3C,MAAvB;SACOoJ,CAAP;;;AClBF;;;;;;AAMA,AAAO,IAAMI,uBAAuB,uBAA7B;AACP,AAAO,IAAMC,4BAA0BD,oBAA1B,MAAN;AACP,IAAME,uBAAuB,iBAA7B;AACA,IAAMC,uBAAqBD,oBAArB,MAAN;AACA,IAAME,4BAAN;AACA,IAAMC,gBAAgB,mBAAtB;;;;;;;;;;;AAWA,SAASC,SAAT,CAAmBC,UAAnB,EAA+BC,YAA/B,EAA6CnJ,KAA7C,EAAoD;8BACGoJ,uBACnDF,UADmD,EAEnDC,YAFmD,CADH;MACpCE,WADoC,yBAC1CtK,IAD0C;MACfuK,aADe,yBACvBnK,MADuB;;MAM5C8H,SAASsC,UAAUL,UAAV,CAAf;MACQM,UAP0C,GAO3BH,WAP2B,CAO1CG,UAP0C;;MAQ9CC,YAAYD,WAAWE,OAAX,CAAmBZ,cAAnB,CAAhB;MACI3J,eAAJ;MACIJ,aAAJ;;;;MAII0K,SAAJ,EAAe;QACPzB,QAAQf,OAAOxF,QAAP,CAAgB+G,WAAhB,EAAd;QACMmB,WAAWF,UAAUC,OAAV,CAAkBX,aAAlB,CAAjB;UACMN,QAAN,CAAekB,QAAf,EAAyB,CAAzB;UACMjB,MAAN,CAAaW,WAAb,EAA0BC,aAA1B;WACOK,QAAP;aACS3B,MAAM4B,QAAN,GAAiBnJ,MAA1B;GANF,MAOO;;;QAGCoJ,WAAWL,WAAWE,OAAX,CAAmBV,aAAnB,CAAjB;QACI,CAACa,QAAL,EAAe,OAAO,IAAP;gBACHA,SAASzC,aAAT,CAAuB0B,cAAvB,CAAZ;QACI,CAACW,SAAL,EAAgB,OAAO,IAAP;WACTA,SAAP;aACS1K,KAAK8I,WAAL,CAAiBpH,MAA1B;;;;;;;MAQAtB,UAAUJ,KAAK8I,WAAL,CAAiBpH,MAA3B,IACA+I,WAAWM,YAAX,CAAwBnB,oBAAxB,CAFF,EAGE;;;;;MAKI3J,YAAYyK,UAAUM,YAAV,CAAuBlB,oBAAvB,CAAlB;MACI,CAAC7J,SAAL,EAAgB,OAAO,IAAP;;yBAEAC,UAAUpB,KAAV,CAAgBmB,SAAhB,CA/CkC;MA+C1Cb,GA/C0C,oBA+C1CA,GA/C0C;;;;;;;MAoD9C,CAAC6B,MAAMyB,QAAN,CAAeuI,aAAf,CAA6B7L,GAA7B,CAAL,EAAwC,OAAO,IAAP;;MAElCmJ,QAAQtH,MAAMyB,QAAN,CAAewI,WAAf,CAA2B,EAAE9L,QAAF,EAAOgB,cAAP,EAA3B,CAAd;SACOmI,KAAP;;;;;;;;;;;;AAYF,SAAS8B,sBAAT,CAAgCrK,IAAhC,EAAsCI,MAAtC,EAA8C;;;MAGxCJ,KAAKmL,QAAL,IAAiB,CAAjB,IAAsBnL,KAAKiG,UAAL,CAAgBvE,MAA1C,EAAkD;QAC1C0J,SAAShL,UAAUJ,KAAKiG,UAAL,CAAgBvE,MAAzC;QACMiG,YAAYyD,SAAS,UAAT,GAAsB,SAAxC;QACM/L,QAAQ+L,SAAShL,SAAS,CAAlB,GAAsBA,MAApC;WACOiL,iBAAiBrL,IAAjB,EAAuBX,KAAvB,EAA8BsI,SAA9B,CAAP;;;;WAIO3H,KAAKmL,QAAL,IAAiB,CAAjB,IAAsBnL,KAAKiG,UAAL,CAAgBvE,MAA7C,EAAqD;UAC7C4B,IAAI8H,SAASpL,KAAKiG,UAAL,CAAgBvE,MAAhB,GAAyB,CAAlC,GAAsC,CAAhD;aACO2J,iBAAiBrL,IAAjB,EAAuBsD,CAAvB,EAA0BqE,SAA1B,CAAP;;;;aAIOyD,SAASpL,KAAK8I,WAAL,CAAiBpH,MAA1B,GAAmC,CAA5C;;;;SAIK,EAAE1B,UAAF,EAAQI,cAAR,EAAP;;;;;;;;;;;;;AAaF,SAASiL,gBAAT,CAA0BtL,MAA1B,EAAkCV,KAAlC,EAAyCsI,SAAzC,EAAoD;MAC1C1B,UAD0C,GAC3BlG,MAD2B,CAC1CkG,UAD0C;;MAE9C1C,QAAQ0C,WAAW5G,KAAX,CAAZ;MACIiE,IAAIjE,KAAR;MACIiM,eAAe,KAAnB;MACIC,gBAAgB,KAApB;;;;SAKEhI,MAAM4H,QAAN,IAAkB,CAAlB,IACC5H,MAAM4H,QAAN,IAAkB,CAAlB,IAAuB5H,MAAM0C,UAAN,CAAiBvE,MAAjB,IAA2B,CADnD,IAEC6B,MAAM4H,QAAN,IAAkB,CAAlB,IAAuB5H,MAAMyH,YAAN,CAAmB,iBAAnB,KAAyC,OAHnE,EAIE;QACIM,gBAAgBC,aAApB,EAAmC;;QAE/BjI,KAAK2C,WAAWvE,MAApB,EAA4B;qBACX,IAAf;UACIrC,QAAQ,CAAZ;kBACY,UAAZ;;;;QAIEiE,IAAI,CAAR,EAAW;sBACO,IAAhB;UACIjE,QAAQ,CAAZ;kBACY,SAAZ;;;;YAIM4G,WAAW3C,CAAX,CAAR;QACIqE,aAAa,SAAjB,EAA4BrE;QACxBqE,aAAa,UAAjB,EAA6BrE;;;SAGxBC,SAAS,IAAhB;;;AC5JF;;;;;;;;AAQA,SAASiI,SAAT,CAAmBC,MAAnB,EAA2BxK,KAA3B,EAAkC;MAC1BmH,KAAKqD,OAAOC,UAAP,IAAqBD,OAAOE,cAAvC;MACI,CAACvD,EAAL,EAAS,OAAO,IAAP;;MAEHF,SAASsC,UAAUpC,EAAV,CAAf;;;;MAKEqD,kBAAkBvD,OAAO0D,KAAzB,IACC1D,OAAO2D,WAAP,IAAsBJ,kBAAkBvD,OAAO2D,WAFlD,EAGE;aACS;kBACKJ,OAAOE,cADZ;oBAEOF,OAAOK,WAFd;iBAGIL,OAAOM,YAHX;mBAIMN,OAAOO;KAJtB;;;gBAcEP,MA1B4B;MAqB9BC,UArB8B,WAqB9BA,UArB8B;MAsB9BO,YAtB8B,WAsB9BA,YAtB8B;MAuB9BC,SAvB8B,WAuB9BA,SAvB8B;MAwB9BC,WAxB8B,WAwB9BA,WAxB8B;MAyB9B9C,WAzB8B,WAyB9BA,WAzB8B;;MA2B1BH,SAASgB,UAAUwB,UAAV,EAAsBO,YAAtB,EAAoChL,KAApC,CAAf;MACMkI,QAAQE,cAAcH,MAAd,GAAuBgB,UAAUgC,SAAV,EAAqBC,WAArB,EAAkClL,KAAlC,CAArC;MACI,CAACiI,MAAD,IAAW,CAACC,KAAhB,EAAuB,OAAO,IAAP;;;;;MAKnBiD,SAASC,OAAb,EAAsB;QACd/C,YAAYhB,aAAaY,MAAb,CAAlB;QACMK,WAAWjB,aAAaa,KAAb,CAAjB;;aAES;kBACKG,UAAUtJ,IADf;oBAEOsJ,UAAUlJ,MAFjB;iBAGImJ,SAASvJ,IAHb;mBAIMuJ,SAASnJ;KAJxB;;;MAQMsC,QA9CwB,GA8CXzB,KA9CW,CA8CxByB,QA9CwB;;MA+C1BuG,QAAQvG,SAAS+G,WAAT,CAAqB;kBAAA;;GAArB,CAAd;;SAKOR,KAAP;;;AC9DF;;;;;;AAMA,IAAMqD,YAAY,CAAC,MAAD,EAAS,SAAT,EAAoB,QAApB,CAAlB;;;;;;AAMA,IAAMC,YAAYC,UAAU,CAAC,CAACtE,OAAOuE,SAAP,CAAiBC,SAAjB,CAA2BC,KAA3B,CAAiC,SAAjC,CAA9B;;;;;;;;AAQA,SAASC,mBAAT,CAA6BxE,EAA7B,EAAiCF,MAAjC,EAAyC;MACnCnI,SAASqI,GAAGqC,UAAhB;MACIoC,iBAAJ;;SAEO,CAACA,QAAR,EAAkB;QACZ,CAAC9M,OAAO0K,UAAZ,EAAwB;;QAElBhI,QAAQyF,OAAO4E,gBAAP,CAAwB/M,MAAxB,CAAd;QACQgN,SAJQ,GAIMtK,KAJN,CAIRsK,SAJQ;;;QAMZT,UAAUU,QAAV,CAAmBD,SAAnB,CAAJ,EAAmC;iBACtBhN,MAAX;;;;aAIOA,OAAO0K,UAAhB;;;;;;;;MAQE,CAACoC,QAAL,EAAe;WACN3E,OAAOxF,QAAP,CAAgBuK,IAAvB;;;SAGKJ,QAAP;;;;;;;;;AASF,SAASK,iBAAT,CAA2B/F,SAA3B,EAAsC;MAChCoF,SAAJ,EAAe;MACX,CAACpF,UAAUuE,UAAf,EAA2B;;MAErBxD,SAASsC,UAAUrD,UAAUuE,UAApB,CAAf;MACMmB,WAAWD,oBAAoBzF,UAAUuE,UAA9B,EAA0CxD,MAA1C,CAAjB;MACMiF,WACJN,YAAY3E,OAAOxF,QAAP,CAAgBuK,IAA5B,IACAJ,YAAY3E,OAAOxF,QAAP,CAAgB0K,eAF9B;MAGMC,WAAWjE,WAAWjC,SAAX,CAAjB;;MAEM8B,QAAQ9B,UAAUmG,UAAV,CAAqB,CAArB,EAAwBC,UAAxB,EAAd;QACMC,QAAN,CAAeH,QAAf;MACII,aAAaxE,MAAMyE,qBAAN,EAAjB;;;;;;;MAOIC,SAAJ,EAAe;QACT1E,MAAM2E,SAAN,IAAmBH,WAAWI,GAAX,IAAkB,CAArC,IAA0CJ,WAAWK,MAAX,IAAqB,CAAnE,EAAsE;UAChE7E,MAAM6C,WAAN,IAAqB,CAAzB,EAA4B;cACpBnC,MAAN,CAAaV,MAAM8C,YAAnB,EAAiC,CAAjC;OADF,MAEO;cACCrC,QAAN,CAAeT,MAAM0C,cAArB,EAAqC1C,MAAM6C,WAAN,GAAoB,CAAzD;;;mBAGW7C,MAAMyE,qBAAN,EAAb;;UAEID,WAAWI,GAAX,IAAkB,CAAlB,IAAuBJ,WAAWK,MAAX,IAAqB,CAAhD,EAAmD;YAC7C7E,MAAM8E,cAAN,GAAuBrM,MAA3B,EAAmC;uBACpBuH,MAAM8E,cAAN,GAAuB,CAAvB,CAAb;;;;;;MAMJC,cAAJ;MACIF,eAAJ;MACIG,gBAAJ;MACIC,gBAAJ;MACIC,cAAc,CAAlB;MACIC,eAAe,CAAnB;MACIC,mBAAmB,CAAvB;MACIC,mBAAmB,CAAvB;MACIC,qBAAqB,CAAzB;MACIC,wBAAwB,CAA5B;MACIC,sBAAsB,CAA1B;MACIC,uBAAuB,CAA3B;;MAEIvB,QAAJ,EAAc;QACJwB,UADI,GACkDzG,MADlD,CACJyG,UADI;QACQC,WADR,GACkD1G,MADlD,CACQ0G,WADR;QACqBC,WADrB,GACkD3G,MADlD,CACqB2G,WADrB;QACkCC,WADlC,GACkD5G,MADlD,CACkC4G,WADlC;;YAEJH,UAAR;aACSC,WAAT;cACUC,WAAV;cACUC,WAAV;GALF,MAMO;QACGC,WADH,GACwDlC,QADxD,CACGkC,WADH;QACgBC,YADhB,GACwDnC,QADxD,CACgBmC,YADhB;QAC8BC,SAD9B,GACwDpC,QADxD,CAC8BoC,SAD9B;QACyCC,UADzC,GACwDrC,QADxD,CACyCqC,UADzC;;gCAWDhH,OAAO4E,gBAAP,CAAwBD,QAAxB,CAXC;QAGHsC,cAHG,yBAGHA,cAHG;QAIHC,iBAJG,yBAIHA,iBAJG;QAKHC,eALG,yBAKHA,eALG;QAMHC,gBANG,yBAMHA,gBANG;QAOHC,UAPG,yBAOHA,UAPG;QAQHC,aARG,yBAQHA,aARG;QASHC,WATG,yBASHA,WATG;QAUHC,YAVG,yBAUHA,YAVG;;QAaCC,eAAe9C,SAASa,qBAAT,EAArB;YACQqB,WAAR;aACSC,YAAT;kBACcW,aAAa9B,GAAb,GAAmBvO,SAAS6P,cAAT,EAAyB,EAAzB,CAAjC;mBACeQ,aAAaC,IAAb,GAAoBtQ,SAAS+P,eAAT,EAA0B,EAA1B,CAAnC;;uBAGE/P,SAAS6P,cAAT,EAAyB,EAAzB,IAA+B7P,SAAS8P,iBAAT,EAA4B,EAA5B,CADjC;;uBAIE9P,SAAS+P,eAAT,EAA0B,EAA1B,IAAgC/P,SAASgQ,gBAAT,EAA2B,EAA3B,CADlC;;yBAGqBhQ,SAASiQ,UAAT,EAAqB,EAArB,CAArB;4BACwBjQ,SAASkQ,aAAT,EAAwB,EAAxB,CAAxB;0BACsBlQ,SAASmQ,WAAT,EAAsB,EAAtB,CAAtB;2BACuBnQ,SAASoQ,YAAT,EAAuB,EAAvB,CAAvB;cACUT,SAAV;cACUC,UAAV;;;MAGIW,YAAYpC,WAAWI,GAAX,GAAiBI,OAAjB,GAA2BE,WAA7C;MACM2B,aAAarC,WAAWmC,IAAX,GAAkB1B,OAAlB,GAA4BE,YAA/C;;MAEI2B,IAAI7B,OAAR;MACI8B,IAAI/B,OAAR;;MAEI6B,aAAa5B,OAAjB,EAA0B;;QAEpB4B,aAAarB,mBAAjB;GAFF,MAGO,IACLqB,aAAarC,WAAWO,KAAxB,GAAgCM,gBAAhC,GACAJ,UAAUF,KAFL,EAGL;;QAEI8B,aAAaxB,gBAAb,GAAgCI,oBAAhC,GAAuDV,KAA3D;;;MAGE6B,YAAY5B,OAAhB,EAAyB;;QAEnB4B,YAAYtB,kBAAhB;GAFF,MAGO,IACLsB,YAAYpC,WAAWK,MAAvB,GAAgCO,gBAAhC,GACAJ,UAAUH,MAFL,EAGL;;QAGE+B,YACAxB,gBADA,GAEAG,qBAFA,GAGAf,WAAWK,MAHX,GAIAA,MALF;;;MAQEX,QAAJ,EAAc;WACL8C,QAAP,CAAgBF,CAAhB,EAAmBC,CAAnB;GADF,MAEO;aACIf,SAAT,GAAqBe,CAArB;aACSd,UAAT,GAAsBa,CAAtB;;;;AC3LJ;;;;;;;;AAQA,SAASG,eAAT,CAAyB/I,SAAzB,EAAoC;MAC5BgJ,MAAMjI,OAAOxF,QAAnB;;MAEIyN,OAAOA,IAAIlD,IAAJ,CAASmD,eAApB,EAAqC;;QAE7BnH,QAAQkH,IAAIlD,IAAJ,CAASmD,eAAT,EAAd;UACM5C,QAAN;UACM6C,MAAN;GAJF,MAKO;cACKH,eAAV;;;;ACDJ,IAAMI,iCAAiC,iDAAvC;;;;;;;;AAQA,IAAM7Q,UAAQC,MAAM,eAAN,CAAd;;;;;;;;IAQM6Q;;;;;;;;;;;;;;uLAoCJC,MAAM;2BACiB;;;;;;;;aASvBC,WAAW9R,eAAe+B,MAAf,CAAsB,UAACgQ,GAAD,EAAMC,OAAN,EAAkB;UAC7CA,OAAJ,IAAe;eAAS,MAAKC,OAAL,CAAaD,OAAb,EAAsBE,KAAtB,CAAT;OAAf;aACOH,GAAP;KAFS,EAGR,EAHQ,SA+DXI,kBAAkB,YAAM;UACdzQ,MADc,GACH,MAAKT,KADF,CACdS,MADc;UAEdY,KAFc,GAEJZ,MAFI,CAEdY,KAFc;UAGdkG,SAHc,GAGAlG,KAHA,CAGdkG,SAHc;UAIdiC,aAJc,GAICjC,SAJD,CAIdiC,UAJc;;UAKhBlB,SAASsC,UAAU,MAAK3J,OAAf,CAAf;UACM4K,SAASvD,OAAO6I,YAAP,EAAf;;;;UAII,CAACtF,MAAL,EAAa;;UAELuF,UAZc,GAYavF,MAZb,CAYduF,UAZc;UAYFtF,UAZE,GAYaD,MAZb,CAYFC,UAZE;;;;UAelB,CAACsF,UAAD,IAAe7J,UAAU8J,SAA7B,EAAwC;;;;UAIpC9J,UAAU8J,SAAd,EAAyB;YACnB,CAAC,MAAKC,UAAL,CAAgBxF,UAAhB,CAAL,EAAkC;wBAClBD,MAAhB;cACK5K,OAAL,CAAasQ,IAAb;gBACM,iBAAN,EAAyB,EAAEhK,oBAAF,EAAasE,cAAb,EAAzB;;;;;UAKEtE,UAAUiK,OAAd,EAAuB;;;UAGjBC,UAAU,CAAC,CAACL,UAAF,IAAgBvF,OAAO6B,UAAP,CAAkB,CAAlB,CAAhC;UACMrE,QAAQD,aAAa7B,SAAb,EAAwBe,MAAxB,CAAd;;UAEI,CAACe,KAAL,EAAY;gBAER,KADF,EAEE,+DAFF;;;;;UAQM0C,cA3Cc,GA2C2C1C,KA3C3C,CA2Cd0C,cA3Cc;UA2CEG,WA3CF,GA2C2C7C,KA3C3C,CA2CE6C,WA3CF;UA2CeC,YA3Cf,GA2C2C9C,KA3C3C,CA2Ce8C,YA3Cf;UA2C6BC,SA3C7B,GA2C2C/C,KA3C3C,CA2C6B+C,SA3C7B;;;;;;;UAiDlBqF,OAAJ,EAAa;YAER1F,kBAAkB0F,QAAQ1F,cAA1B,IACCG,eAAeuF,QAAQvF,WADxB,IAECC,gBAAgBsF,QAAQtF,YAFzB,IAGCC,aAAaqF,QAAQrF,SAHvB,IAICL,kBAAkB0F,QAAQtF,YAA1B,IACCD,eAAeuF,QAAQrF,SADxB,IAECD,gBAAgBsF,QAAQ1F,cAFzB,IAGCK,aAAaqF,QAAQvF,WARzB,EASE;;;;;;YAMC0E,GAAL,CAASc,mBAAT,GAA+B,IAA/B;sBACgB7F,MAAhB;;;UAGIA,OAAO8F,gBAAX,EAA6B;;;YAGvBnI,aAAJ,EAAgB;iBACPmI,gBAAP,CACEtI,MAAM8C,YADR,EAEE9C,MAAM+C,SAFR,EAGE/C,MAAM0C,cAHR,EAIE1C,MAAM6C,WAJR;SADF,MAOO;iBACEyF,gBAAP,CACEtI,MAAM0C,cADR,EAEE1C,MAAM6C,WAFR,EAGE7C,MAAM8C,YAHR,EAIE9C,MAAM+C,SAJR;;OAXJ,MAkBO;;eAEEwF,QAAP,CAAgBvI,KAAhB;;;;wBAIgBwC,MAAlB;;;iBAGW,YAAM;;;YAGXgG,cAAc,MAAK5Q,OAAvB,EAAgC,MAAKA,OAAL,CAAasI,KAAb;cAC3BqH,GAAL,CAASc,mBAAT,GAA+B,KAA/B;OAJF;;cAOM,iBAAN,EAAyB,EAAEnK,oBAAF,EAAasE,cAAb,EAAzB;aASFiG,MAAM,mBAAW;YACV7Q,OAAL,GAAeA,OAAf;aAYFqQ,aAAa,kBAAU;;UACbrQ,OADa,UACbA,OADa;;;UAGjBuH,WAAJ;;UAEI;;;YAGEuJ,OAAOxG,QAAP,KAAoB,CAAxB,EAA2B;iBAClB,KAAP;;;;;aAKGwG,OAAOxG,QAAP,KAAoB,CAApB,GAAwBwG,OAAOlH,UAA/B,GAA4CkH,MAAjD;OATF,CAUE,OAAOC,GAAP,EAAY;;;;;YAKRH,cAAcnB,+BAA+BuB,IAA/B,CAAoCD,IAAIvP,OAAxC,CAAlB,EAAoE;iBAC3D,KAAP;;;cAGIuP,GAAN;;;UAGIE,YAAY1J,GAAG2J,iBAAH,IAAwB3J,GAAGuC,OAAH,CAAW,mBAAX,CAA1C;aAEEmH,cACC1J,OAAOvH,OAAP,IAAkBuH,GAAGuC,OAAH,CAAW,qBAAX,MAAsC9J,OADzD,CADF;aA0FFmR,0BAA0BC,SAAS,iBAAS;UACtC,MAAKrS,KAAL,CAAWwE,QAAf,EAAyB;;UAEnB8D,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;UACQO,aAJkC,GAIhBhK,OAAOxF,QAJS,CAIlCwP,aAJkC;;UAKtCA,kBAAkB,MAAKrR,OAA3B,EAAoC;;YAE/BjB,KAAL,CAAWuS,QAAX,CAAoBtB,KAApB;KAPwB,EAQvB,GARuB,SAyF1BpJ,aAAa,UAAClE,KAAD,EAAQ0D,UAAR,EAAoBzE,WAApB,EAAoC;wBAClB,MAAK5C,KADa;UACvCS,MADuC,eACvCA,MADuC;UAC/B+D,QAD+B,eAC/BA,QAD+B;UAEvCnD,KAFuC,GAE7BZ,MAF6B,CAEvCY,KAFuC;UAGvCyB,QAHuC,GAGfzB,KAHe,CAGvCyB,QAHuC;UAG7ByE,SAH6B,GAGflG,KAHe,CAG7BkG,SAH6B;UAIvCD,SAJuC,GAIzBC,SAJyB,CAIvCD,SAJuC;;;aAO7C,oBAACH,MAAD;eACS,IADT;gBAEU1G,MAFV;qBAGemC,WAHf;oBAIcyE,UAJd;mBAKaC,aAAaD,UAL1B;aAMO1D,MAAMnE,GANb;cAOQmE,KAPR;gBAQUb,QARV;kBASY0B;QAVd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCArYkB;UACZ8D,SAASsC,UAAU,KAAK3J,OAAf,CAAf;;aAEO6B,QAAP,CAAgB0P,gBAAhB,CACE,iBADF,EAEE,KAAKJ,uBAFP;;;;UAOIK,wBAAJ,EAA8B;aACvBxR,OAAL,CAAauR,gBAAb,CAA8B,aAA9B,EAA6C,KAAK3B,QAAL,CAAc6B,aAA3D;;;WAGGxB,eAAL;;;;;;;;;2CAOqB;UACf5I,SAASsC,UAAU,KAAK3J,OAAf,CAAf;;UAEIqH,MAAJ,EAAY;eACHxF,QAAP,CAAgB6P,mBAAhB,CACE,iBADF,EAEE,KAAKP,uBAFP;;;UAMEK,wBAAJ,EAA8B;aACvBxR,OAAL,CAAa0R,mBAAb,CACE,aADF,EAEE,KAAK9B,QAAL,CAAc6B,aAFhB;;;;;;;;;;yCAWiB;WACdxB,eAAL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA6KMH,SAASE,OAAO;cAChB,SAAN,EAAiBF,OAAjB;;;;UAKE,KAAKH,GAAL,CAASc,mBAAT,KACCX,WAAW,UAAX,IAAyBA,WAAW,QAApC,IAAgDA,WAAW,SAD5D,CADF,EAGE;;;;;;;;;UASEA,WAAW,UAAf,EAA2B;YACjBtQ,MADiB,GACN,KAAKT,KADC,CACjBS,MADiB;YAEjBY,KAFiB,GAEPZ,MAFO,CAEjBY,KAFiB;YAGjBkG,SAHiB,GAGHlG,KAHG,CAGjBkG,SAHiB;;YAInBe,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;YACMlG,SAASvD,OAAO6I,YAAP,EAAf;YACM9H,QAAQuC,UAAUC,MAAV,EAAkBxK,KAAlB,CAAd;;YAEIgI,SAASA,MAAM/E,MAAN,CAAaiD,UAAUqL,OAAV,EAAb,CAAb,EAAgD;eACzC1B,eAAL;;;;;;UAOFH,WAAW,WAAX,IACAA,WAAW,aADX,IAEAA,WAAW,YAFX,IAGAA,WAAW,aAHX,IAIAA,WAAW,YAJX,IAKAA,WAAW,aALX,IAMAA,WAAW,QAPb,EAQE;YACQgB,MADR,GACmBd,KADnB,CACQc,MADR;;YAEMc,mBAAmBd,OAAOhH,OAAP,CAAe,qBAAf,CAAzB;YACI8H,qBAAqB,KAAK5R,OAA9B,EAAuC;;;;;UAMvC8P,WAAW,eAAX,IACAA,WAAW,QADX,IAEAA,WAAW,kBAFX,IAGAA,WAAW,oBAHX,IAIAA,WAAW,QAJX,IAKAA,WAAW,OALX,IAMAA,WAAW,SANX,IAOAA,WAAW,SAPX,IAQAA,WAAW,WARX,IASAA,WAAW,SATX,IAUAA,WAAW,SAVX,IAWAA,WAAW,UAZb,EAaE;YACI,CAAC,KAAKO,UAAL,CAAgBL,MAAMc,MAAtB,CAAL,EAAoC;;;WAGjC/R,KAAL,CAAW+Q,OAAX,EAAoBE,KAApB;;;;;;;;;;;;;;;;;;;;;;6BA4BO;;;UACCjR,KADD,GACqB,IADrB,CACCA,KADD;UACQ6Q,QADR,GACqB,IADrB,CACQA,QADR;UAGLiC,SAHK,GAUH9S,KAVG,CAGL8S,SAHK;UAILtO,QAJK,GAUHxE,KAVG,CAILwE,QAJK;UAKL/D,MALK,GAUHT,KAVG,CAKLS,MALK;UAMLsS,QANK,GAUH/S,KAVG,CAML+S,QANK;UAOLC,IAPK,GAUHhT,KAVG,CAOLgT,IAPK;UAQLC,OARK,GAUHjT,KAVG,CAQLiT,OARK;UASLC,UATK,GAUHlT,KAVG,CASLkT,UATK;UAWC7R,KAXD,GAWkBZ,MAXlB,CAWCY,KAXD;UAWQX,KAXR,GAWkBD,MAXlB,CAWQC,KAXR;;UAYDyS,YAAYF,OAAlB;UACQnQ,QAbD,GAasCzB,KAbtC,CAaCyB,QAbD;UAaWyE,SAbX,GAasClG,KAbtC,CAaWkG,SAbX;UAasB3E,WAbtB,GAasCvB,KAbtC,CAasBuB,WAbtB;;UAcD4E,UAAU1E,SAAS2E,mBAAT,CAA6BF,SAA7B,CAAhB;UACMxE,OAAOD,SAAS6E,cAAT,CAAwBjH,KAAxB,EAA+BgH,MAA/B,CAAsC9E,WAAtC,CAAb;UACMyC,sBAAsBJ,uBAAuBnC,QAAvB,EAAiCC,IAAjC,CAA5B;;UAEMhC,WAAW+B,SAAStB,KAAT,CAAeyE,OAAf,GAAyBxC,GAAzB,CAA6B,UAACE,KAAD,EAAQD,CAAR,EAAc;YACpD2D,aAAa,CAAC,CAACG,OAAF,IAAaA,QAAQvE,KAAR,IAAiBS,CAA9B,IAAmCA,IAAI8D,QAAQrE,GAAlE;;eAEO,OAAK0E,UAAL,CAAgBlE,KAAhB,EAAuB0D,UAAvB,EAAmChC,oBAAoB3B,CAApB,CAAnC,CAAP;OAHe,CAAjB;;UAMMb;;iBAEK,MAFL;;oBAIQ,UAJR;;kBAMM;SAIN2B,WAAW,EAAX,GAAgB,EAAE4O,kBAAkB,2BAApB,EAVhB,EAYDpT,MAAM6C,KAZL,CAAN;;cAeM,QAAN,EAAgB,EAAE7C,YAAF,EAAhB;;aAGE;iBAAA;qBACM6Q,QADN;mCAAA;eAGO,KAAKiB,GAHZ;sBAIYhP,SAAStD,GAJrB;2BAKmBgF,WAAW,IAAX,GAAkB,IALrC;8CAAA;qBAOasO,SAPb;uBAQe9S,MAAMqT,WAAN,GAAoB,IAApB,GAA2B,KAR1C;sBAScH,UATd;iBAUSrQ,KAVT;gBAWQ2B,WAAW,IAAX,GAAkBwO,QAAQ,SAXlC;oBAYYD;;;;YAIV,cAAY;;;OAjBhB;;;;;;;;;;;;;EAzZkB7Q,MAAMC;;;;;;AAAtBwO,QAOGvO,YAAY;eACJG,MAAMsC,IAAN,CAAWvC,UADP;aAENC,MAAMpD,MAFA;UAGToD,MAAM3C,MAAN,CAAa0C,UAHJ;YAIPC,MAAMsC,IAAN,CAAWvC,UAJJ;QAKXC,MAAMpD,MALK;cAMLoD,MAAMsC,IAAN,CAAWvC,UANN;SAOVC,MAAM3C,MAPI;YAQP2C,MAAMC,MARC;WASRD,MAAMpD,MATE;AAPfwR,QAyBG5M,eAAe;SACb,EADa;WAEX,KAFW;AA0bxBhF,eAAeuG,OAAf,CAAuB,mBAAW;UACxBlD,SAAR,CAAkB2O,OAAlB,IAA6BxO,MAAM+Q,IAAN,CAAWhR,UAAxC;CADF;;ACnfA;;;;;;AAMA,IAAMiR,iBAAiB;YACX,8BADW;QAEf,WAFe;QAGf,0BAHe;QAIf,UAJe;QAKf;;;;;;;;CALR;;ICIQC,WAAyBD,eAAzBC;IAAUC,OAAeF,eAAfE;IAAMC,OAASH,eAATG;;;;;;;;;;AAUxB,SAASC,aAAT,CACE1C,KADF,EAEE5P,KAFF,EAKE;MAFAuS,QAEA,uEAFWvS,MAAMuS,QAEjB;MADAC,QACA,uEADW;WAAMpN,SAAN;GACX;;MACM6B,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;MACMlG,SAASvD,OAAO6I,YAAP,EAAf;MACQ7P,MAHR,GAGmBD,KAHnB,CAGQC,MAHR;yBAIuBD,MAAMkG,SAJ7B;MAIQtE,KAJR,oBAIQA,KAJR;MAIeE,GAJf,oBAIeA,GAJf;;MAKM2Q,YAAYzS,MAAMyB,QAAN,CAAeiR,cAAf,CAA8B9Q,MAAMzD,GAApC,EAAyC8B,MAAzC,CAAlB;MACM0S,UAAU3S,MAAMyB,QAAN,CAAeiR,cAAf,CAA8B5Q,IAAI3D,GAAlC,EAAuC8B,MAAvC,CAAhB;;;MAGIuK,OAAOpC,WAAP,IAAsB,CAACqK,SAA3B,EAAsC;;;;MAIhCG,UAAUC,OAAOC,aAAP,CAAqBP,QAArB,CAAhB;MACMvK,QAAQwC,OAAO6B,UAAP,CAAkB,CAAlB,CAAd;MACI0G,WAAW/K,MAAMgL,aAAN,EAAf;MACIC,SAASF,SAAS/N,UAAT,CAAoB,CAApB,CAAb;;;WAGSA,UAAT,CAAoBf,OAApB,CAA4B,gBAAQ;QAC9BlF,KAAK8I,WAAL,IAAoB9I,KAAK8I,WAAL,CAAiBqL,IAAjB,OAA4B,EAApD,EAAwD;eAC7CnU,IAAT;;GAFJ;;;;;MASI4T,OAAJ,EAAa;QACLpK,IAAIP,MAAMsE,UAAN,EAAV;QACMvN,OAAOgI,cAAY4L,OAAZ,EAAqB1L,MAArB,CAAb;MACEkM,WAAF,CAAcpU,IAAd;eACWwJ,EAAEyK,aAAF,EAAX;;;;;;;MAOEP,SAAJ,EAAe;aACJM,SAAS/N,UAAT,CAAoB,CAApB,EAAuBA,UAAvB,CAAkC,CAAlC,EAAqCoO,UAA9C;;;;;EAKD,GAAGC,KAAH,CAASC,IAAT,CAAcP,SAASQ,gBAAT,CAA0B3K,mBAA1B,CAAd,EAA8D3E,OAA9D,CAAsE,cAAM;QACrEuP,YAAYC,GAAG1J,YAAH,CAAgBpB,oBAAhB,MAA0C,GAA5D;OACGd,WAAH,GAAiB2L,YAAY,IAAZ,GAAmB,EAApC;GAFD;;;;;MAQGP,OAAO/I,QAAP,IAAmB,CAAvB,EAA0B;QAClBwJ,OAAOzM,OAAOxF,QAAP,CAAgBkS,aAAhB,CAA8B,MAA9B,CAAb;;;;SAIKnS,KAAL,CAAWoS,UAAX,GAAwB,KAAxB;;SAEKC,WAAL,CAAiBZ,MAAjB;aACSY,WAAT,CAAqBH,IAArB;aACSA,IAAT;;;SAGKI,YAAP,CAAoB,qBAApB,EAA2ClB,OAA3C;;;;;MAKMmB,mBAAmBC,MAAMC,MAAN,CAAa,EAAExS,UAAU8Q,QAAZ,EAAb,CAAzB;MACM2B,YAAYC,MAAMC,SAAN,CAAgBL,gBAAhB,CAAlB;;;;MAIMM,MAAMpN,OAAOxF,QAAP,CAAgBkS,aAAhB,CAA8B,KAA9B,CAAZ;MACIE,WAAJ,CAAgBd,QAAhB;;;;;;;;MAQInD,MAAM0E,aAAN,IAAuB1E,MAAM0E,aAAN,CAAoBC,OAA3C,IAAsD,CAACpJ,KAA3D,EAAkE;UAC1DqJ,cAAN;UACMF,aAAN,CAAoBC,OAApB,CAA4BlC,IAA5B,EAAkC6B,SAAlC;UACMI,aAAN,CAAoBC,OAApB,CAA4BpC,QAA5B,EAAsCS,OAAtC;UACM0B,aAAN,CAAoBC,OAApB,CAA4BnC,IAA5B,EAAkCiC,IAAII,SAAtC;;;;;;;MAOIrV,SAASwQ,MAAMc,MAAN,CAAahH,OAAb,CAAqB,qBAArB,CAAf;MACIoK,YAAJ,CAAiB,iBAAjB,EAAoC,IAApC;MACItS,KAAJ,CAAUkT,QAAV,GAAqB,UAArB;MACIlT,KAAJ,CAAUmN,IAAV,GAAiB,SAAjB;SACOkF,WAAP,CAAmBQ,GAAnB;SACOM,iBAAP,CAAyBN,GAAzB;;;SAGOO,qBAAP,CAA6B,YAAM;WAC1BC,WAAP,CAAmBR,GAAnB;oBACgB7J,MAAhB;WACO+F,QAAP,CAAgBvI,KAAhB;;GAHF;;;AChIF;;;;;;;;AAQA,SAAS8M,QAAT,CAAkBlV,OAAlB,EAA2BI,KAA3B,EAAkC;MAC1B0J,UAAU9J,QAAQ8J,OAAR,CAAgB,YAAhB,CAAhB;MACI,CAACA,OAAL,EAAc,OAAO,IAAP;;MAERvL,MAAMuL,QAAQK,YAAR,CAAqB,UAArB,CAAZ;MACI,CAAC5L,GAAL,EAAU,OAAO,IAAP;;MAEJY,OAAOiB,MAAMyB,QAAN,CAAesT,OAAf,CAAuB5W,GAAvB,CAAb;SACOY,QAAQ,IAAf;;;ACXF;;;;;;;;AAQA,SAASiW,aAAT,CAAuBpF,KAAvB,EAA8B5P,KAA9B,EAAqC;MAC/B4P,MAAMqF,WAAV,EAAuB;YACbrF,MAAMqF,WAAd;;;eAGuBrF,KALU;MAK3Bd,CAL2B,UAK3BA,CAL2B;MAKxBC,CALwB,UAKxBA,CALwB;MAKrB2B,MALqB,UAKrBA,MALqB;;MAM/B5B,KAAK,IAAL,IAAaC,KAAK,IAAtB,EAA4B,OAAO,IAAP;;MAEpBtN,QAR2B,GAQNzB,KARM,CAQ3ByB,QAR2B;MAQjBxB,MARiB,GAQND,KARM,CAQjBC,MARiB;;MAS7BlB,OAAO+V,SAASpE,MAAT,EAAiB1Q,KAAjB,CAAb;MACI,CAACjB,IAAL,EAAW,OAAO,IAAP;;;;;MAKPkB,OAAOC,MAAP,CAAcnB,IAAd,CAAJ,EAAyB;QACjBmW,OAAOxE,OAAOjE,qBAAP,EAAb;QACM0I,aACJpW,KAAKR,MAAL,IAAe,QAAf,GACIuQ,IAAIoG,KAAKvG,IAAT,GAAgBuG,KAAKvG,IAAL,GAAYuG,KAAKnI,KAAjB,GAAyB+B,CAD7C,GAEIC,IAAImG,KAAKtI,GAAT,GAAesI,KAAKtI,GAAL,GAAWsI,KAAKrI,MAAhB,GAAyBkC,CAH9C;;QAKMlQ,OAAOE,KAAK4E,YAAL,EAAb;QACMqE,SAAQvG,SAAS+G,WAAT,EAAd;;QAEI2M,UAAJ,EAAgB;UACRC,eAAe3T,SAAS4T,eAAT,CAAyBxW,KAAKV,GAA9B,CAArB;;UAEIiX,YAAJ,EAAkB;eACTpN,OAAMsN,eAAN,CAAsBF,YAAtB,CAAP;;;;QAIEG,WAAW9T,SAAS+T,WAAT,CAAqB3W,KAAKV,GAA1B,CAAjB;WACOoX,WAAWvN,OAAMyN,iBAAN,CAAwBF,QAAxB,CAAX,GAA+C,IAAtD;;;;MAIItO,SAASsC,UAAUmH,MAAV,CAAf;MACIlG,eAAJ;;;MAGIvD,OAAOxF,QAAP,CAAgBiU,mBAApB,EAAyC;aAC9BzO,OAAOxF,QAAP,CAAgBiU,mBAAhB,CAAoC5G,CAApC,EAAuCC,CAAvC,CAAT;GADF,MAEO,IAAI9H,OAAOxF,QAAP,CAAgBkU,sBAApB,EAA4C;QAC3CjB,WAAWzN,OAAOxF,QAAP,CAAgBkU,sBAAhB,CAAuC7G,CAAvC,EAA0CC,CAA1C,CAAjB;aACS9H,OAAOxF,QAAP,CAAgB+G,WAAhB,EAAT;WACOC,QAAP,CAAgBiM,SAASkB,UAAzB,EAAqClB,SAASvV,MAA9C;WACOuJ,MAAP,CAAcgM,SAASkB,UAAvB,EAAmClB,SAASvV,MAA5C;GAJK,MAKA,IAAI8H,OAAOxF,QAAP,CAAgBuK,IAAhB,CAAqBmD,eAAzB,EAA0C;;;aAGtClI,OAAOxF,QAAP,CAAgBuK,IAAhB,CAAqBmD,eAArB,EAAT;;QAEI;aACK0G,WAAP,CAAmB/G,CAAnB,EAAsBC,CAAtB;KADF,CAEE,OAAO+G,KAAP,EAAc;;;aAGP,IAAP;;;;;MAKE9N,QAAQuC,UAAUC,MAAV,EAAkBxK,KAAlB,CAAd;MACI,CAACgI,KAAL,EAAY,OAAO,IAAP;;SAELA,KAAP;;;AC5EF;;;;;;IAMQmK,aAAqCD,eAArCC;IAAUC,SAA2BF,eAA3BE;IAAM2D,OAAqB7D,eAArB6D;IAAMC,OAAe9D,eAAf8D;IAAM3D,SAASH,eAATG;;;;;;;;AAQpC,IAAM4D,mBAAmB,kCAAzB;;;;;;;;;AASA,SAASC,gBAAT,CAA0BtG,KAA1B,EAAiC;;;;MAI3B,CAACzE,KAAD,IAAUyE,MAAMqF,WAApB,EAAiC;YACvBrF,MAAMqF,WAAd;;;MAGIkB,WAAWvG,MAAMwG,YAAN,IAAsBxG,MAAM0E,aAA7C;MACI/B,WAAW8D,QAAQF,QAAR,EAAkBhE,UAAlB,CAAf;MACIpT,OAAOsX,QAAQF,QAAR,EAAkBJ,IAAlB,CAAX;MACMO,OAAOD,QAAQF,QAAR,EAAkB/D,MAAlB,CAAb;MACMmE,OAAOF,QAAQF,QAAR,EAAkBH,IAAlB,CAAb;MACInX,OAAOwX,QAAQF,QAAR,EAAkB9D,MAAlB,CAAX;MACImE,cAAJ;;;;MAII,CAACjE,QAAD,IAAa+D,IAAb,IAAqB,CAACA,KAAKG,OAAL,CAAa,wBAAb,CAA1B,EAAkE;QAC1D1Y,UAAUkY,iBAAiBjY,IAAjB,CAAsBsY,IAAtB,CAAhB;;iCACwBvY,OAFwC;QAEzD2Y,IAFyD;QAEnD9D,OAFmD;;;QAG5DA,OAAJ,EAAaL,WAAWK,OAAX;;;;;MAKX/T,IAAJ,EAAU;QACF8X,gBAAgBC,iBAAiB/X,IAAjB,CAAtB;;QAEI8X,cAAcxE,UAAd,CAAJ,EAA6BI,WAAWoE,cAAcxE,UAAd,CAAX;QACzBwE,cAAcZ,IAAd,CAAJ,EAAyBhX,OAAO4X,cAAcZ,IAAd,CAAP;QACrBY,cAActE,MAAd,CAAJ,EAAyBxT,OAAO8X,cAActE,MAAd,CAAP;;;;MAIvBE,QAAJ,EAAcA,WAAWM,OAAOgE,eAAP,CAAuBtE,QAAvB,CAAX;MACVxT,IAAJ,EAAUA,OAAO8T,OAAOgE,eAAP,CAAuB9X,IAAvB,CAAP;;;;MAIN;;QAEEoX,SAASW,KAAT,IAAkBX,SAASW,KAAT,CAAerW,MAArC,EAA6C;cACnCsW,MAAMC,IAAN,CAAWb,SAASW,KAApB,EACL1U,GADK,CACD;eAAS8B,KAAK+S,IAAL,IAAa,MAAb,GAAsB/S,KAAKgT,SAAL,EAAtB,GAAyC,IAAlD;OADC,EAELvV,MAFK,CAEE;eAAUwV,MAAV;OAFF,CAAR;KADF,MAIO,IAAIhB,SAASK,KAAT,IAAkBL,SAASK,KAAT,CAAe/V,MAArC,EAA6C;cAC1CsW,MAAMC,IAAN,CAAWb,SAASK,KAApB,CAAR;;GAPJ,CASE,OAAO7F,GAAP,EAAY;QACRwF,SAASK,KAAT,IAAkBL,SAASK,KAAT,CAAe/V,MAArC,EAA6C;cACnCsW,MAAMC,IAAN,CAAWb,SAASK,KAApB,CAAR;;;;;MAKEY,OAAO,EAAEZ,YAAF,EAASjE,kBAAT,EAAmB+D,UAAnB,EAAyBvX,UAAzB,EAA+BwX,UAA/B,EAAqC1X,UAArC,EAAb;OACK4E,IAAL,GAAY4T,gBAAgBD,IAAhB,CAAZ;SACOA,IAAP;;;;;;;;;;;AAWF,SAASR,gBAAT,CAA0B/X,IAA1B,EAAgC;MACxByY,SAAS,oBAAf;;MAEIzY,KAAK0Y,SAAL,CAAe,CAAf,EAAkBD,OAAO7W,MAAzB,KAAoC6W,MAAxC,EAAgD;WACvC,EAAEjF,MAAMxT,IAAR,EAAP;;;;;MAKE;WACK2Y,KAAK3Z,KAAL,CAAWgB,KAAK0Y,SAAL,CAAeD,OAAO7W,MAAtB,CAAX,CAAP;GADF,CAEE,OAAOkQ,GAAP,EAAY;UACN,IAAI1S,KAAJ,CAAU,+CAAV,CAAN;;;;;;;;;;;AAWJ,SAASoZ,eAAT,CAAyBD,IAAzB,EAA+B;MACzBA,KAAK7E,QAAT,EAAmB,OAAO,UAAP;MACf6E,KAAKrY,IAAT,EAAe,OAAO,MAAP;;;;;;MAMXqY,KAAKb,IAAL,IAAaa,KAAKd,IAAtB,EAA4B,OAAO,MAAP;MACxBc,KAAKb,IAAL,IAAaa,KAAKvY,IAAtB,EAA4B,OAAO,MAAP;;MAExBuY,KAAKZ,KAAL,IAAcY,KAAKZ,KAAL,CAAW/V,MAA7B,EAAqC,OAAO,OAAP;MACjC2W,KAAKd,IAAT,EAAe,OAAO,MAAP;MACXc,KAAKvY,IAAT,EAAe,OAAO,MAAP;SACR,SAAP;;;;;;;;;;;;AAYF,SAASwX,OAAT,CAAiBF,QAAjB,EAA2B1S,IAA3B,EAAiC;MAC3B,CAAC0S,SAASsB,KAAV,IAAmB,CAACtB,SAASsB,KAAT,CAAehX,MAAvC,EAA+C;;;WAGtCgD,QAAQ4O,MAAR,GAAe8D,SAASuB,OAAT,CAAiB,MAAjB,KAA4B,IAA3C,GAAkD,IAAzD;;;;MAIID,QAAQV,MAAMC,IAAN,CAAWb,SAASsB,KAApB,CAAd;;SAEOA,MAAMhB,OAAN,CAAchT,IAAd,MAAwB,CAAC,CAAzB,GAA6B0S,SAASuB,OAAT,CAAiBjU,IAAjB,KAA0B,IAAvD,GAA8D,IAArE;;;ACzJF;;;;;;IAMQ4O,SAASH,eAATG;;;;;;;;;;;;;AAaR,SAASsF,gBAAT,CAA0B/H,KAA1B,EAAiCnM,IAAjC,EAAuCH,OAAvC,EAAgD;MACxCsU,OAAO1F,eAAezO,KAAKoU,WAAL,EAAf,CAAb;;MAEI,CAACD,IAAL,EAAW;UACH,IAAI3Z,KAAJ,wCAA+C2Z,IAA/C,QAAN;;;MAGEhI,MAAMqF,WAAV,EAAuB;YACbrF,MAAMqF,WAAd;;;MAGIkB,WAAWvG,MAAMwG,YAAN,IAAsBxG,MAAM0E,aAA7C;;MAEI;aACOC,OAAT,CAAiBqD,IAAjB,EAAuBtU,OAAvB;;;aAGSiR,OAAT,CAAiB,MAAjB,EAAyB4B,SAASuB,OAAT,CAAiB,MAAjB,CAAzB;GAJF,CAKE,OAAO/G,GAAP,EAAY;QACN2G,SAAS,oBAAf;QACMzY,OAAOsX,SAASuB,OAAT,CAAiBrF,MAAjB,CAAb;QACI5C,MAAM,EAAV;;;QAGI5Q,KAAK0Y,SAAL,CAAe,CAAf,EAAkBD,OAAO7W,MAAzB,MAAqC6W,MAAzC,EAAiD;UAC3C;cACIE,KAAK3Z,KAAL,CAAWgB,KAAK0Y,SAAL,CAAeD,OAAO7W,MAAtB,CAAX,CAAN;OADF,CAEE,OAAOqX,CAAP,EAAU;cACJ,IAAI7Z,KAAJ,CACJ,wDADI,CAAN;;KAJJ,MAQO;;UAEDoU,MAAJ,IAAYxT,IAAZ;;;QAGE+Y,IAAJ,IAAYtU,OAAZ;QACMxF,cAAYwZ,MAAZ,GAAqBE,KAAKlZ,SAAL,CAAemR,GAAf,CAA3B;aACS8E,OAAT,CAAiBlC,MAAjB,EAAuBvU,MAAvB;;;;ACzCJ;;;;;;AAMA,IAAMU,UAAQC,MAAM,aAAN,CAAd;;;;;;;;AAQA,SAASsZ,WAAT,GAAuB;MACjBC,uBAAuB,IAA3B;;;;;;;;;;WAUS3G,aAAT,CAAuBzB,KAAvB,EAA8BqI,MAA9B,EAAsC7Y,MAAtC,EAA8C;YACtC,eAAN,EAAuB,EAAEwQ,YAAF,EAAvB;;QAEMsI,cAAc,CAAC,CAACtI,MAAMqF,WAA5B;;;;;QAKIiD,WAAJ,EAAiB;YACT1D,cAAN;aACO2D,UAAP,CAAkBvI,MAAMwH,IAAxB;;;;;;;gCAMoBxH,MAAMwI,eAAN,EAhBsB;;QAgBrCC,WAhBqC;;QAiBxC,CAACA,WAAL,EAAkB;;UAEZ7D,cAAN;;QAEQxU,KArBoC,GAqB1BiY,MArB0B,CAqBpCjY,KArBoC;QAsBpCyB,QAtBoC,GAsBJzB,KAtBI,CAsBpCyB,QAtBoC;QAsB1ByE,SAtB0B,GAsBJlG,KAtBI,CAsB1BkG,SAtB0B;QAsBfjG,MAtBe,GAsBJD,KAtBI,CAsBfC,MAtBe;;QAuBtC+H,QAAQuC,UAAU8N,WAAV,EAAuBrY,KAAvB,CAAd;;YAEQ4P,MAAM0I,SAAd;WACO,cAAL;WACK,aAAL;WACK,eAAL;WACK,uBAAL;WACK,sBAAL;;iBACSC,aAAP,CAAqBvQ,KAArB;;;;WAIG,oBAAL;;iBACSwQ,yBAAP,CAAiCxQ,KAAjC;;;;WAIG,mBAAL;;iBACSyQ,wBAAP,CAAgCzQ,KAAhC;;;;WAIG,wBAAL;WACK,wBAAL;;iBACS0Q,yBAAP,CAAiC1Q,KAAjC;;;;WAIG,uBAAL;WACK,uBAAL;;iBACS2Q,wBAAP,CAAgC3Q,KAAhC;;;;WAIG,iBAAL;WACK,iBAAL;;cACQ4Q,gBAAgBnX,SAASmX,aAAT,CACpB1S,UAAUtE,KAAV,CAAgBG,IADI,EAEpB9B,MAFoB,CAAtB;;cAKI2Y,aAAJ,EAAmB;mBACVC,qBAAP;WADF,MAEO;mBACEC,iBAAP,CAAyB9Q,KAAzB;;;;;;WAMC,gBAAL;WACK,uBAAL;WACK,YAAL;;;;;;cAKQnJ,OACJ+Q,MAAMwH,IAAN,IAAc,IAAd,GACIxH,MAAMwG,YAAN,CAAmBsB,OAAnB,CAA2B,YAA3B,CADJ,GAEI9H,MAAMwH,IAHZ;;cAKIvY,QAAQ,IAAZ,EAAkB;;iBAEXka,iBAAP,CAAyB/Q,KAAzB,EAAgCnJ,IAAhC,EAAsCqH,UAAUtH,KAAhD;;;;cAIIsH,UAAUtH,KAAV,IAAmBoB,MAAMyB,QAAN,IAAkBwW,OAAOjY,KAAP,CAAayB,QAAtD,EAAgE;mBACvD2N,MAAP,CAAc,EAAExQ,OAAO,IAAT,EAAd;;;;;;;;;;;;;;;;WAgBCoa,MAAT,CAAgBpJ,KAAhB,EAAuBqI,MAAvB,EAA+B7Y,MAA/B,EAAuC;YAC/B,QAAN,EAAgB,EAAEwQ,YAAF,EAAhB;;WAEOM,IAAP;;;;;;;;;;;WAWO+I,OAAT,CAAiBrJ,KAAjB,EAAwBqI,MAAxB,EAAgC7Y,MAAhC,EAAwC;QAClCA,OAAOT,KAAP,CAAawE,QAAjB,EAA2B;aAClB,IAAP;;;QAGMnD,KAL8B,GAKpBiY,MALoB,CAK9BjY,KAL8B;QAM9ByB,QAN8B,GAMTzB,KANS,CAM9ByB,QAN8B;QAMpBxB,MANoB,GAMTD,KANS,CAMpBC,MANoB;;QAOhClB,OAAO+V,SAASlF,MAAMc,MAAf,EAAuB1Q,KAAvB,CAAb;;QAEI,CAACjB,IAAL,EAAW;;;;QAILma,YAAYzX,SAAS0X,YAAT,CAAsBpa,KAAKZ,GAA3B,CAAlB;QACM+B,SACJnB,SAASkB,OAAOC,MAAP,CAAcnB,IAAd,KAAuBma,UAAUE,IAAV,CAAe;aAAKnZ,OAAOC,MAAP,CAAcsF,CAAd,CAAL;KAAf,CAAhC,CADF;;QAGItF,MAAJ,EAAY;;;;;aAKHgI,KAAP,GAAeoN,eAAf,CAA+BvW,IAA/B;;;YAGI,SAAN,EAAiB,EAAE6Q,YAAF,EAAjB;;;;;;;;;;;WAWOyJ,MAAT,CAAgBzJ,KAAhB,EAAuBqI,MAAvB,EAA+B7Y,MAA/B,EAAuC;YAC/B,QAAN,EAAgB,EAAEwQ,YAAF,EAAhB;;kBAEcA,KAAd,EAAqBqI,OAAOjY,KAA5B;;;;;;;;;;;WAWOsZ,KAAT,CAAe1J,KAAf,EAAsBqI,MAAtB,EAA8B7Y,MAA9B,EAAsC;YAC9B,OAAN,EAAe,EAAEwQ,YAAF,EAAf;;;;kBAIcA,KAAd,EAAqBqI,OAAOjY,KAA5B,EAAmCiY,OAAOjY,KAAP,CAAauS,QAAhD,EAA0D,YAAM;;;UAGtDvS,KAHsD,GAG5CiY,MAH4C,CAGtDjY,KAHsD;UAItDuZ,QAJsD,GAIXvZ,KAJW,CAItDuZ,QAJsD;UAI5CC,SAJ4C,GAIXxZ,KAJW,CAI5CwZ,SAJ4C;UAIjCtT,SAJiC,GAIXlG,KAJW,CAIjCkG,SAJiC;UAItBjG,MAJsB,GAIXD,KAJW,CAItBC,MAJsB;UAKtDmI,WALsD,GAKtClC,SALsC,CAKtDkC,WALsD;;UAMxDqR,cAAcF,YAAYtZ,OAAOC,MAAP,CAAcqZ,QAAd,CAAZ,IAAuCnR,WAA3D;UACMsR,eAAeF,aAAavZ,OAAOC,MAAP,CAAcsZ,SAAd,CAAb,IAAyCpR,WAA9D;;UAEIqR,WAAJ,EAAiB;eACRxB,MAAP,CAAc;iBAAK0B,EAAEC,eAAF,CAAkBL,SAASpb,GAA3B,CAAL;SAAd;OADF,MAEO,IAAIub,YAAJ,EAAkB;eAChBzB,MAAP,CAAc;iBAAK0B,EAAEC,eAAF,CAAkBJ,UAAUrb,GAA5B,CAAL;SAAd;OADK,MAEA;eACE8Z,MAAP,CAAc;iBAAK0B,EAAEE,MAAF,EAAL;SAAd;;KAdJ;;;;;;;;;;;WA2BOC,SAAT,CAAmBlK,KAAnB,EAA0BqI,MAA1B,EAAkC7Y,MAAlC,EAA0C;YAClC,WAAN,EAAmB,EAAEwQ,YAAF,EAAnB;;2BAEuB,IAAvB;;;;;;;;;;;WAWOmK,UAAT,CAAoBnK,KAApB,EAA2BqI,MAA3B,EAAmC7Y,MAAnC,EAA2C;YACnC,YAAN,EAAoB,EAAEwQ,YAAF,EAApB;;;;;;;;;;;WAWOoK,WAAT,CAAqBpK,KAArB,EAA4BqI,MAA5B,EAAoC7Y,MAApC,EAA4C;YACpC,aAAN,EAAqB,EAAEwQ,YAAF,EAArB;;2BAEuB,IAAvB;;QAEQ5P,KALkC,GAKxBiY,MALwB,CAKlCjY,KALkC;QAMlCyB,QANkC,GAMbzB,KANa,CAMlCyB,QANkC;QAMxBxB,MANwB,GAMbD,KANa,CAMxBC,MANwB;;QAOpClB,OAAO+V,SAASlF,MAAMc,MAAf,EAAuB1Q,KAAvB,CAAb;QACMkZ,YAAYzX,SAAS0X,YAAT,CAAsBpa,KAAKZ,GAA3B,CAAlB;QACM+B,SACJnB,SAASkB,OAAOC,MAAP,CAAcnB,IAAd,KAAuBma,UAAUE,IAAV,CAAe;aAAKnZ,OAAOC,MAAP,CAAcsF,CAAd,CAAL;KAAf,CAAhC,CADF;QAEMyU,wBAAwBja,MAAMka,MAAN,CAAad,IAAb,CAC5B;aAAStZ,MAAM3B,GAAN,KAAcY,KAAKZ,GAA5B;KAD4B,CAA9B;;;QAKI+B,UAAU,CAAC+Z,qBAAf,EAAsC;aAC7BE,iBAAP,CAAyBpb,IAAzB;;;QAGIwT,WAAW0F,OAAOjY,KAAP,CAAauS,QAA9B;QACMK,UAAUC,OAAOC,aAAP,CAAqBP,QAArB,CAAhB;qBACiB3C,KAAjB,EAAwB,UAAxB,EAAoCgD,OAApC;;;;;;;;;;;WAWOwH,MAAT,CAAgBxK,KAAhB,EAAuBqI,MAAvB,EAA+B7Y,MAA/B,EAAuC;YAC/B,QAAN,EAAgB,EAAEwQ,YAAF,EAAhB;;QAEQ5P,KAH6B,GAGnBiY,MAHmB,CAG7BjY,KAH6B;QAI7ByB,QAJ6B,GAIGzB,KAJH,CAI7ByB,QAJ6B;QAInByE,SAJmB,GAIGlG,KAJH,CAInBkG,SAJmB;QAIRjG,MAJQ,GAIGD,KAJH,CAIRC,MAJQ;;QAK/BgH,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;QACIA,SAASsE,cAAcpF,KAAd,EAAqB5P,KAArB,CAAb;QACI,CAAC0Q,MAAL,EAAa;;QAEPyF,WAAWD,iBAAiBtG,KAAjB,CAAjB;QACQnM,IAV6B,GAUJ0S,QAVI,CAU7B1S,IAV6B;QAUvB8O,QAVuB,GAUJ4D,QAVI,CAUvB5D,QAVuB;QAUb1T,IAVa,GAUJsX,QAVI,CAUbtX,IAVa;;;WAY9BqJ,KAAP;;;;QAKE8P,wBACA9R,UAAUpE,GAAV,CAAc3D,GAAd,IAAqBuS,OAAO5O,GAAP,CAAW3D,GADhC,IAEA+H,UAAUpE,GAAV,CAAc3C,MAAd,GAAuBuR,OAAO5O,GAAP,CAAW3C,MAHpC,EAIE;eACSuR,OAAO2J,WAAP,CACPnU,UAAUtE,KAAV,CAAgBzD,GAAhB,IAAuB+H,UAAUpE,GAAV,CAAc3D,GAArC,GACI,IAAI+H,UAAUpE,GAAV,CAAc3C,MAAlB,GAA2B+G,UAAUtE,KAAV,CAAgBzC,MAD/C,GAEI,IAAI+G,UAAUpE,GAAV,CAAc3C,MAHf,CAAT;;;QAOE6Y,oBAAJ,EAA0B;aACjB6B,MAAP;;;WAGKzK,MAAP,CAAcsB,MAAd;;QAEIjN,QAAQ,MAAR,IAAkBA,QAAQ,MAA9B,EAAsC;oBACjBiN,MADiB;UAC5BzI,MAD4B,WAC5BA,MAD4B;;UAEhC2Q,gBAAgBnX,SAASmX,aAAT,CAAuB3Q,OAAO9J,GAA9B,EAAmC8B,MAAnC,CAApB;;UAEI2Y,aAAJ,EAAmB;YACbhW,IAAInB,SAASsT,OAAT,CAAiB9M,OAAO9J,GAAxB,CAAR;;eAEOya,aAAP,EAAsB;cAChBnX,SAAS+T,WAAT,CAAqB5S,EAAEzE,GAAvB,CAAJ;cACI,CAACyE,CAAL,EAAQ;0BACQnB,SAASmX,aAAT,CAAuBhW,EAAEzE,GAAzB,EAA8B8B,MAA9B,CAAhB;;;YAGE2C,CAAJ,EAAOqV,OAAOxC,iBAAP,CAAyB7S,CAAzB;;;UAGL/D,IAAJ,EAAU;aACHyb,KAAL,CAAW,IAAX,EAAiBrW,OAAjB,CAAyB,UAACsW,IAAD,EAAOlY,CAAP,EAAa;cAChCA,IAAI,CAAR,EAAW4V,OAAOuC,UAAP;iBACJrC,UAAP,CAAkBoC,IAAlB;SAFF;;;;QAOA9W,QAAQ,UAAZ,EAAwB;aACfgX,cAAP,CAAsBlI,QAAtB;;;;;;;QAOItH,YAAYxJ,SAASsT,OAAT,CAAiBrE,OAAOxI,KAAP,CAAa/J,GAA9B,CAAlB;QACMgJ,KAAKJ,cAAYkE,SAAZ,EAAuBhE,MAAvB,CAAX;QACI,CAACE,EAAL,EAAS;;OAENuT,aAAH,CACE,IAAIC,UAAJ,CAAe,SAAf,EAA0B;YAClB1T,MADkB;eAEf,IAFe;kBAGZ;KAHd,CADF;;;;;;;;;;WAgBO2T,OAAT,CAAiBhL,KAAjB,EAAwBqI,MAAxB,EAAgC7Y,MAAhC,EAAwC;YAChC,SAAN,EAAiB,EAAEwQ,YAAF,EAAjB;;QAEM3I,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;QACQ1Q,KAJ8B,GAIpBiY,MAJoB,CAI9BjY,KAJ8B;;;;QAOhCwK,SAASvD,OAAO6I,YAAP,EAAf;QACQrF,UAR8B,GAQfD,MARe,CAQ9BC,UAR8B;;QAShCnD,QAAQ2B,UAAUwB,UAAV,EAAsB,CAAtB,EAAyBzK,KAAzB,CAAd;QACI,CAACsH,KAAL,EAAY;;;QAGJ7F,QAb8B,GAaNzB,KAbM,CAa9ByB,QAb8B;QAapByE,SAboB,GAaNlG,KAbM,CAapBkG,SAboB;;QAchCnH,OAAO0C,SAASoZ,aAAT,CAAuBvT,MAAMnJ,GAA7B,CAAb;QACM2B,QAAQ2B,SAASqZ,eAAT,CAAyB/b,KAAKZ,GAA9B,CAAd;QACM4B,SAAShB,KAAKoD,SAAL,EAAf;QACM9B,WAAWP,MAAMQ,WAAN,EAAjB;QACMya,WAAWhb,OAAOK,IAAP,EAAjB;QACIwB,QAAQ,CAAZ;QACIE,MAAM,CAAV;;QAEMxC,OACJS,OAAOF,IAAP,CAAY,aAAK;cACPiC,GAAR;aACOyG,EAAE1J,IAAF,CAAO4B,MAAd;UACIqB,MAAMwF,MAAMnI,MAAhB,EAAwB,OAAO,IAAP;KAH1B,KAIM4b,QALR;;;QAQQlc,IA9B8B,GA8BrBS,IA9BqB,CA8B9BT,IA9B8B;QA+BhCgJ,WA/BgC,GA+BhB4C,UA/BgB,CA+BhC5C,WA/BgC;;QAgChCnH,aAAa3B,QAAQsB,QAA3B;QACMM,aAAarB,QAAQyb,QAA3B;QACMxa,WAAWsH,YAAYrH,MAAZ,CAAmBqH,YAAYpH,MAAZ,GAAqB,CAAxC,CAAjB;;;;;QAKIC,cAAcC,UAAd,IAA4BJ,YAAY,IAA5C,EAAkD;oBAClCsH,YAAYwL,KAAZ,CAAkB,CAAlB,EAAqB,CAAC,CAAtB,CAAd;;;;QAIExL,eAAehJ,IAAnB,EAAyB;;;QAGnBmc,QAAQnT,YAAYpH,MAAZ,GAAqB5B,KAAK4B,MAAxC;QACMwa,YAAY/U,UAAUgV,SAAV,GAAsBb,WAAtB,CAAkCW,KAAlC,CAAlB;QACIG,SAASjV,UACVkV,YADU,CACG9T,MAAMnJ,GADT,EACcyD,KADd,EAEVyZ,WAFU,CAEE/T,MAAMnJ,GAFR,EAEa2D,GAFb,CAAb;;aAISL,SAAS6Z,YAAT,CAAsBH,MAAtB,CAAT;;;WAGOpC,iBAAP,CAAyBoC,MAAzB,EAAiCtT,WAAjC,EAA8CvI,KAAKV,KAAnD,EAA0DwQ,MAA1D,CAAiE6L,SAAjE;;;;;;;;;;;WAWOM,SAAT,CAAmB3L,KAAnB,EAA0BqI,MAA1B,EAAkC7Y,MAAlC,EAA0C;YAClC,WAAN,EAAmB,EAAEwQ,YAAF,EAAnB;;QAEQ5P,KAHgC,GAGtBiY,MAHsB,CAGhCjY,KAHgC;QAIhCyB,QAJgC,GAIAzB,KAJA,CAIhCyB,QAJgC;QAItByE,SAJsB,GAIAlG,KAJA,CAItBkG,SAJsB;QAIXjG,MAJW,GAIAD,KAJA,CAIXC,MAJW;;QAKlC2Y,gBAAgBnX,SAASmX,aAAT,CAAuB1S,UAAUtE,KAAV,CAAgBG,IAAvC,EAA6C9B,MAA7C,CAAtB;;;;;QAKIub,QAAQC,YAAR,CAAqB7L,KAArB,KAA+B,CAACrE,MAApC,EAA4C;aACnCqN,gBACHX,OAAOY,qBAAP,EADG,GAEHZ,OAAOuC,UAAP,EAFJ;;;QAKEgB,QAAQE,gBAAR,CAAyB9L,KAAzB,KAAmC,CAACrE,MAAxC,EAAgD;aACvC0M,OAAO0D,kBAAP,EAAP;;;QAGEH,QAAQI,eAAR,CAAwBhM,KAAxB,KAAkC,CAACrE,MAAvC,EAA+C;aACtC0M,OAAO4D,iBAAP,EAAP;;;QAGEL,QAAQM,oBAAR,CAA6BlM,KAA7B,CAAJ,EAAyC;aAChCqI,OAAO8D,kBAAP,EAAP;;;QAGEP,QAAQQ,mBAAR,CAA4BpM,KAA5B,CAAJ,EAAwC;aAC/BqI,OAAOgE,iBAAP,EAAP;;;QAGET,QAAQU,oBAAR,CAA6BtM,KAA7B,CAAJ,EAAyC;aAChCqI,OAAOkE,kBAAP,EAAP;;;QAGEX,QAAQY,mBAAR,CAA4BxM,KAA5B,CAAJ,EAAwC;aAC/BqI,OAAOoE,iBAAP,EAAP;;;QAGEb,QAAQc,MAAR,CAAe1M,KAAf,CAAJ,EAA2B;aAClBqI,OAAOsE,IAAP,EAAP;;;QAGEf,QAAQgB,MAAR,CAAe5M,KAAf,CAAJ,EAA2B;aAClBqI,OAAOwE,IAAP,EAAP;;;;;;QAMEjB,QAAQkB,kBAAR,CAA2B9M,KAA3B,CAAJ,EAAuC;YAC/B4E,cAAN;aACOyD,OAAO0E,kBAAP,EAAP;;;QAGEnB,QAAQoB,iBAAR,CAA0BhN,KAA1B,CAAJ,EAAsC;YAC9B4E,cAAN;aACOyD,OAAO4E,gBAAP,EAAP;;;QAGErB,QAAQsB,oBAAR,CAA6BlN,KAA7B,CAAJ,EAAyC;YACjC4E,cAAN;aACOyD,OAAO8E,uBAAP,EAAP;;;QAGEvB,QAAQwB,mBAAR,CAA4BpN,KAA5B,CAAJ,EAAwC;YAChC4E,cAAN;aACOyD,OAAOgF,qBAAP,EAAP;;;;;;QAMEzB,QAAQ0B,cAAR,CAAuBtN,KAAvB,CAAJ,EAAmC;UACzBwF,YADyB,GACGpV,KADH,CACzBoV,YADyB;UACX+H,SADW,GACGnd,KADH,CACXmd,SADW;;UAE3BC,mBACJhI,gBAAgB3T,SAASmX,aAAT,CAAuBxD,aAAajX,GAApC,EAAyC8B,MAAzC,CADlB;;UAGI2Y,iBAAiBwE,gBAAjB,IAAqCD,UAAUte,IAAV,IAAkB,EAA3D,EAA+D;cACvD2V,cAAN;eACOyD,OAAOoF,YAAP,EAAP;;;;QAIA7B,QAAQ8B,aAAR,CAAsB1N,KAAtB,CAAJ,EAAkC;UACxB2F,QADwB,GACAvV,KADA,CACxBuV,QADwB;UACd4H,UADc,GACAnd,KADA,CACdmd,SADc;;UAE1BI,eACJhI,YAAY9T,SAASmX,aAAT,CAAuBrD,SAASpX,GAAhC,EAAqC8B,MAArC,CADd;;UAGI2Y,iBAAiB2E,YAAjB,IAAiCJ,WAAUte,IAAV,IAAkB,EAAvD,EAA2D;cACnD2V,cAAN;eACOyD,OAAOoC,WAAP,EAAP;;;;QAIAmB,QAAQgC,gBAAR,CAAyB5N,KAAzB,CAAJ,EAAqC;UAC3BwF,aAD2B,GACCpV,KADD,CAC3BoV,YAD2B;UACb+H,WADa,GACCnd,KADD,CACbmd,SADa;;UAE7BC,oBACJhI,iBAAgB3T,SAASmX,aAAT,CAAuBxD,cAAajX,GAApC,EAAyC8B,MAAzC,CADlB;;UAGI2Y,iBAAiBwE,iBAAjB,IAAqCD,YAAUte,IAAV,IAAkB,EAA3D,EAA+D;cACvD2V,cAAN;eACOyD,OAAOwF,iBAAP,EAAP;;;;QAIAjC,QAAQkC,eAAR,CAAwB9N,KAAxB,CAAJ,EAAoC;UAC1B2F,SAD0B,GACFvV,KADE,CAC1BuV,QAD0B;UAChB4H,WADgB,GACFnd,KADE,CAChBmd,SADgB;;UAE5BI,gBACJhI,aAAY9T,SAASmX,aAAT,CAAuBrD,UAASpX,GAAhC,EAAqC8B,MAArC,CADd;;UAGI2Y,iBAAiB2E,aAAjB,IAAiCJ,YAAUte,IAAV,IAAkB,EAAvD,EAA2D;cACnD2V,cAAN;eACOyD,OAAO0F,gBAAP,EAAP;;;;;;;;;;;;;WAaGC,OAAT,CAAiBhO,KAAjB,EAAwBqI,MAAxB,EAAgC7Y,MAAhC,EAAwC;YAChC,SAAN,EAAiB,EAAEwQ,YAAF,EAAjB;;QAEMuG,WAAWD,iBAAiBtG,KAAjB,CAAjB;QACQnM,IAJ8B,GAIL0S,QAJK,CAI9B1S,IAJ8B;QAIxB8O,QAJwB,GAIL4D,QAJK,CAIxB5D,QAJwB;QAId1T,IAJc,GAILsX,QAJK,CAIdtX,IAJc;;;QAMlC4E,QAAQ,UAAZ,EAAwB;aACfgX,cAAP,CAAsBlI,QAAtB;;;QAGE9O,QAAQ,MAAR,IAAkBA,QAAQ,MAA9B,EAAsC;UAChC,CAAC5E,IAAL,EAAW;UACHmB,KAF4B,GAElBiY,MAFkB,CAE5BjY,KAF4B;UAG5ByB,QAH4B,GAGgBzB,KAHhB,CAG5ByB,QAH4B;UAGlByE,SAHkB,GAGgBlG,KAHhB,CAGlBkG,SAHkB;UAGP2X,UAHO,GAGgB7d,KAHhB,CAGP6d,UAHO;UAGK5d,MAHL,GAGgBD,KAHhB,CAGKC,MAHL;;UAIhCA,OAAOC,MAAP,CAAc2d,UAAd,CAAJ,EAA+B;;UAEzBC,eAAeD,UAArB;UACME,eAAetc,SAASuc,qBAAT,CAA+B9X,SAA/B,CAArB;UACM+X,OAAO9J,MAAM+J,WAAN,CAAkBrf,IAAlB,EAAwB,EAAEif,0BAAF,EAAgBC,0BAAhB,EAAxB,EACVtc,QADH;aAEOgZ,cAAP,CAAsBwD,IAAtB;;;;;;;;;;;;WAYK/M,QAAT,CAAkBtB,KAAlB,EAAyBqI,MAAzB,EAAiC7Y,MAAjC,EAAyC;YACjC,UAAN,EAAkB,EAAEwQ,YAAF,EAAlB;;QAEM3I,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;QACQ1Q,KAJ+B,GAIrBiY,MAJqB,CAI/BjY,KAJ+B;QAK/ByB,QAL+B,GAKVzB,KALU,CAK/ByB,QAL+B;QAKrBxB,MALqB,GAKVD,KALU,CAKrBC,MALqB;;QAMjCuK,SAASvD,OAAO6I,YAAP,EAAf;;;QAGI,CAACtF,OAAOuF,UAAZ,EAAwB;aACfG,IAAP;;;;;QAKElI,QAAQuC,UAAUC,MAAV,EAAkBxK,KAAlB,CAAZ;QACI,CAACgI,KAAL,EAAY;;iBAEcA,KAlBa;QAkB/BC,MAlB+B,UAkB/BA,MAlB+B;QAkBvBC,KAlBuB,UAkBvBA,KAlBuB;;QAmBjCiW,aAAa1c,SAASsT,OAAT,CAAiB9M,OAAO9J,GAAxB,CAAnB;QACMigB,YAAY3c,SAASsT,OAAT,CAAiB7M,MAAM/J,GAAvB,CAAlB;QACMkgB,eAAe5c,SAAS6c,gBAAT,CAA0BrW,OAAO9J,GAAjC,CAArB;QACMogB,cAAc9c,SAAS6c,gBAAT,CAA0BpW,MAAM/J,GAAhC,CAApB;QACMqgB,aAAa/c,SAASqZ,eAAT,CAAyB5S,MAAM/J,GAA/B,CAAnB;QACMsgB,cAAchd,SAASqZ,eAAT,CAAyB7S,OAAO9J,GAAhC,CAApB;;;;;;;;;QAUEsgB,eACA,CAACxe,OAAOC,MAAP,CAAcue,WAAd,CADD,IAEAxW,OAAO9I,MAAP,IAAiB,CAFjB,IAGAqf,UAHA,IAIAve,OAAOC,MAAP,CAAcse,UAAd,CAJA,IAKAtW,MAAM/I,MAAN,IAAgB,CANlB,EAOE;cACQ6I,MAAM0W,QAAN,CAAexW,MAAMyW,SAAN,CAAgB,CAAhB,CAAf,CAAR;;;;;;QAOAN,gBACA,CAACpe,OAAOC,MAAP,CAAcme,YAAd,CADD,IAEApW,OAAO9I,MAAP,IAAiBgf,WAAWtf,IAAX,CAAgB4B,MAHnC,EAIE;UACMX,QAAQ2B,SAASqZ,eAAT,CAAyB7S,OAAO9J,GAAhC,CAAd;UACMygB,OAAO9e,MAAM0V,WAAN,CAAkBvN,OAAO9J,GAAzB,CAAb;UACIygB,IAAJ,EAAU5W,QAAQA,MAAMoT,YAAN,CAAmBwD,KAAKzgB,GAAxB,EAA6B,CAA7B,CAAR;;;QAIVogB,eACA,CAACte,OAAOC,MAAP,CAAcqe,WAAd,CADD,IAEArW,MAAM/I,MAAN,IAAgBif,UAAUvf,IAAV,CAAe4B,MAHjC,EAIE;UACMX,SAAQ2B,SAASqZ,eAAT,CAAyB5S,MAAM/J,GAA/B,CAAd;UACMygB,QAAO9e,OAAM0V,WAAN,CAAkBtN,MAAM/J,GAAxB,CAAb;UACIygB,KAAJ,EAAU5W,QAAQA,MAAMqT,WAAN,CAAkBuD,MAAKzgB,GAAvB,EAA4B,CAA5B,CAAR;;;QAGR+H,YAAYzE,SAASod,eAAT,CAAyB7W,KAAzB,CAAhB;gBACY9B,UAAU4Y,YAAV,CAAuB,IAAvB,CAAZ;;;;gBAIY5Y,UAAU6Y,GAAV,CAAc,OAAd,EAAuB/e,MAAMkG,SAAN,CAAgBtH,KAAvC,CAAZ;;WAEOwQ,MAAP,CAAclJ,SAAd;;;;;;;;;;;WAWO8Y,YAAT,CAAsBrgB,KAAtB,EAA6BS,MAA7B,EAAqC;QAC3BoQ,QAD2B,GACdpQ,MADc,CAC3BoQ,QAD2B;;WAGjC,oBAAC,OAAD,eACMA,QADN;mBAEe7Q,MAAMqT,WAFrB;iBAGarT,MAAM8S,SAHnB;cAIUrS,MAJV;gBAKYT,MAAMwE,QALlB;YAMQxE,MAAMgT,IANd;kBAOchT,MAAMkT,UAPpB;aAQSlT,MAAM6C,KARf;gBASY7C,MAAM+S,QATlB;eAUW/S,MAAMiT;OAXnB;;;;;;;;;;WAuBOpL,UAAT,CAAoB7H,KAApB,EAA2B;QACjBa,UADiB,GACcb,KADd,CACjBa,UADiB;QACLE,QADK,GACcf,KADd,CACLe,QADK;QACKX,IADL,GACcJ,KADd,CACKI,IADL;;QAErBA,KAAKR,MAAL,IAAe,OAAf,IAA0BQ,KAAKR,MAAL,IAAe,QAA7C,EAAuD;QACjD6E,MAAMrE,KAAKR,MAAL,IAAe,OAAf,GAAyB,KAAzB,GAAiC,MAA7C;QACMiD,QAAQ,EAAEkT,UAAU,UAAZ,EAAd;WAEE;SAAA;mBAASlV,UAAT,IAAqB,OAAOgC,KAA5B;;KADF;;;;;;;;;;WAcOyd,iBAAT,CAA2BtgB,KAA3B,EAAkC;QACxBS,MADwB,GACPT,KADO,CACxBS,MADwB;QAChBL,IADgB,GACPJ,KADO,CAChBI,IADgB;;QAE5B,CAACK,OAAOT,KAAP,CAAakI,WAAlB,EAA+B;QAC3BzH,OAAO8f,KAAP,CAAaC,WAAjB,EAA8B;QAC1BpgB,KAAKR,MAAL,IAAe,OAAnB,EAA4B;QACxB,CAAC+C,KAAK8d,UAAL,CAAgBrgB,KAAKoB,KAArB,CAAL,EAAkC;QAC9BpB,KAAKF,IAAL,IAAa,EAAjB,EAAqB;QACjBO,OAAOY,KAAP,CAAayB,QAAb,CAAsB4d,SAAtB,GAAkCze,IAAlC,GAAyC,CAA7C,EAAgD;;QAE1CY,QAAQ;qBACG,MADH;eAEH,cAFG;aAGL,GAHK;gBAIF,MAJE;kBAKA,QALA;eAMH;KANX;;WAUE;;QAAM,iBAAiB,KAAvB,EAA8B,OAAOA,KAArC;aACU7C,KAAP,CAAakI;KAFlB;;;;;;;;;SAaK;gCAAA;kBAAA;oBAAA;kBAAA;gBAAA;wBAAA;0BAAA;4BAAA;kBAAA;oBAAA;wBAAA;oBAAA;sBAAA;8BAAA;0BAAA;;GAAP;;;AC9vBF;;;;;;AAMA,IAAMrI,UAAQC,MAAM,cAAN,CAAd;;;;;;;;AAQA,SAAS6gB,YAAT,GAAwB;MAClBrO,gBAAgB,IAApB;MACIsO,mBAAmB,CAAvB;MACIJ,cAAc,KAAlB;MACIK,YAAY,KAAhB;MACIC,aAAa,KAAjB;;;;;;;;;;WAUSpO,aAAT,CAAuBzB,KAAvB,EAA8BqI,MAA9B,EAAsC7Y,MAAtC,EAA8C;QACxCA,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;QAErB+U,cAAc,CAAC,CAACtI,MAAMqF,WAA5B;;;;;QAKIiD,eAAe9G,wBAAnB,EAA6C,OAAO,IAAP;;YAEvC,eAAN,EAAuB,EAAExB,YAAF,EAAvB;;;;;;;;;;;WAWOoJ,MAAT,CAAgBpJ,KAAhB,EAAuBqI,MAAvB,EAA+B7Y,MAA/B,EAAuC;QACjCogB,SAAJ,EAAe,OAAO,IAAP;QACXpgB,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;QAEnBnD,KAJ6B,GAInBiY,MAJmB,CAI7BjY,KAJ6B;QAK7BC,MAL6B,GAKlBD,KALkB,CAK7BC,MAL6B;QAM7Byf,aAN6B,GAMH9P,KANG,CAM7B8P,aAN6B;QAMdhP,MANc,GAMHd,KANG,CAMdc,MANc;;QAO/BzJ,SAASsC,UAAUmH,MAAV,CAAf;;;;;;QAMIO,iBAAiBhK,OAAOxF,QAAP,CAAgBwP,aAArC,EAAoD,OAAO,IAAP;;;;QAIhDyO,aAAJ,EAAmB;UACXvY,KAAKJ,YAAY3H,MAAZ,CAAX;;;;;UAKIsgB,iBAAiBvY,EAArB,EAAyB,OAAO,IAAP;;;;UAIrBuY,cAAc5V,YAAd,CAA2B,mBAA3B,CAAJ,EAAqD,OAAO,IAAP;;;;;UAK/C/K,OAAO+V,SAAS4K,aAAT,EAAwB1f,KAAxB,CAAb;UACImH,GAAGwY,QAAH,CAAYD,aAAZ,KAA8B3gB,IAA9B,IAAsC,CAACkB,OAAOC,MAAP,CAAcnB,IAAd,CAA3C,EACE,OAAO,IAAP;;;YAGE,QAAN,EAAgB,EAAE6Q,YAAF,EAAhB;;;;;;;;;;WAUOgQ,QAAT,CAAkB3H,MAAlB,EAA0B7Y,MAA1B,EAAkC;QACxBY,KADwB,GACdiY,MADc,CACxBjY,KADwB;;;;;;QAM5BA,MAAMC,MAAN,IAAgBb,OAAOa,MAA3B,EAAmC;aAC1B4f,aAAP,CAAqB,YAAM;eAClBC,QAAP,CAAgB,EAAE7f,QAAQb,OAAOa,MAAjB,EAAhB,EAA2C8f,SAA3C;OADF;;;YAKI,UAAN;;;;;;;;;;;WAWOC,gBAAT,CAA0BpQ,KAA1B,EAAiCqI,MAAjC,EAAyC7Y,MAAzC,EAAiD;QACzCwD,IAAI2c,gBAAV;;;;;WAKO3K,qBAAP,CAA6B,YAAM;UAC7B2K,mBAAmB3c,CAAvB,EAA0B;oBACZ,KAAd;;;;;;UAMIxD,OAAO8f,KAAP,CAAaC,WAAjB,EAA8B;eACrBc,QAAP,CAAgB,EAAEd,aAAa,KAAf,EAAhB;;KATJ;;YAaM,kBAAN,EAA0B,EAAEvP,YAAF,EAA1B;;;;;;;;;;;WAWOsQ,kBAAT,CAA4BtQ,KAA5B,EAAmCqI,MAAnC,EAA2C7Y,MAA3C,EAAmD;kBACnC,IAAd;;;;;;;QAOI,CAACA,OAAO8f,KAAP,CAAaC,WAAlB,EAA+B;aACtBc,QAAP,CAAgB,EAAEd,aAAa,IAAf,EAAhB;;;YAGI,oBAAN,EAA4B,EAAEvP,YAAF,EAA5B;;;;;;;;;;;WAWOyJ,MAAT,CAAgBzJ,KAAhB,EAAuBqI,MAAvB,EAA+B7Y,MAA/B,EAAuC;QAC/B6H,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;gBACY,IAAZ;WACOkE,qBAAP,CAA6B;aAAO4K,YAAY,KAAnB;KAA7B;;YAEM,QAAN,EAAgB,EAAE5P,YAAF,EAAhB;;;;;;;;;;;WAWO0J,KAAT,CAAe1J,KAAf,EAAsBqI,MAAtB,EAA8B7Y,MAA9B,EAAsC;QAChCA,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;QAErB8D,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;gBACY,IAAZ;WACOkE,qBAAP,CAA6B;aAAO4K,YAAY,KAAnB;KAA7B;;YAEM,OAAN,EAAe,EAAE5P,YAAF,EAAf;;;;;;;;;;;WAWOkK,SAAT,CAAmBlK,KAAnB,EAA0BqI,MAA1B,EAAkC7Y,MAAlC,EAA0C;iBAC3B,KAAb;;YAEM,WAAN,EAAmB,EAAEwQ,YAAF,EAAnB;;;;;;;;;;;WAWOuQ,WAAT,CAAqBvQ,KAArB,EAA4BqI,MAA5B,EAAoC7Y,MAApC,EAA4C;YACpC,aAAN,EAAqB,EAAEwQ,YAAF,EAArB;;;;;;;;;;;WAWOwQ,UAAT,CAAoBxQ,KAApB,EAA2BqI,MAA3B,EAAmC7Y,MAAnC,EAA2C;YACnC,YAAN,EAAoB,EAAEwQ,YAAF,EAApB;;;;;;;;;;;WAWOyQ,WAAT,CAAqBzQ,KAArB,EAA4BqI,MAA5B,EAAoC7Y,MAApC,EAA4C;YACpC,aAAN,EAAqB,EAAEwQ,YAAF,EAArB;;;;;;;;;;;WAWOmK,UAAT,CAAoBnK,KAApB,EAA2BqI,MAA3B,EAAmC7Y,MAAnC,EAA2C;;;;;QAKjCY,KALiC,GAKvBZ,MALuB,CAKjCY,KALiC;QAMjCC,MANiC,GAMtBD,KANsB,CAMjCC,MANiC;;QAOnClB,OAAO+V,SAASlF,MAAMc,MAAf,EAAuBtR,OAAOY,KAA9B,CAAb;QACIC,OAAOC,MAAP,CAAcnB,IAAd,CAAJ,EAAyB6Q,MAAM4E,cAAN;;;;;;QAMrBrJ,KAAJ,EAAWyE,MAAM4E,cAAN;;;QAGP,CAACiL,UAAL,EAAiB;mBACF,IAAb;;;;UAII,CAACtU,KAAL,EAAY;cACJ8J,WAAN,CAAkBmB,YAAlB,CAA+BkK,UAA/B,GAA4C,MAA5C;;;;YAIE,YAAN,EAAoB,EAAE1Q,YAAF,EAApB;;;;;;;;;;;WAWOoK,WAAT,CAAqBpK,KAArB,EAA4BqI,MAA5B,EAAoC7Y,MAApC,EAA4C;iBAC7B,IAAb;;YAEM,aAAN,EAAqB,EAAEwQ,YAAF,EAArB;;;;;;;;;;;WAWOwK,MAAT,CAAgBxK,KAAhB,EAAuBqI,MAAvB,EAA+B7Y,MAA/B,EAAuC;;QAEjCA,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;;UAGrBqR,cAAN;;YAEM,QAAN,EAAgB,EAAE5E,YAAF,EAAhB;;;;;;;;;;;WAWO2Q,OAAT,CAAiB3Q,KAAjB,EAAwBqI,MAAxB,EAAgC7Y,MAAhC,EAAwC;QAClCogB,SAAJ,EAAe,OAAO,IAAP;QACXpgB,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;QAErBgE,KAAKJ,YAAY3H,MAAZ,CAAX;;;QAGM6H,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;oBACgBzJ,OAAOxF,QAAP,CAAgBwP,aAAhC;;;;;QAKIT,cAAcZ,MAAMc,MAAN,IAAgBvJ,EAAlC,EAAsC;SACjCe,KAAH;aACO,IAAP;;;YAGI,SAAN,EAAiB,EAAE0H,YAAF,EAAjB;;;;;;;;;;;WAWOgL,OAAT,CAAiBhL,KAAjB,EAAwBqI,MAAxB,EAAgC7Y,MAAhC,EAAwC;QAClC+f,WAAJ,EAAiB,OAAO,IAAP;QACblH,OAAOjY,KAAP,CAAakG,SAAb,CAAuB8J,SAA3B,EAAsC,OAAO,IAAP;;YAEhC,SAAN,EAAiB,EAAEJ,YAAF,EAAjB;;;;;;;;;;;WAWO2L,SAAT,CAAmB3L,KAAnB,EAA0BqI,MAA1B,EAAkC7Y,MAAlC,EAA0C;QACpCA,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;;;;QAKvBgc,WAAJ,EAAiB;UACX3D,QAAQgF,SAAR,CAAkB5Q,KAAlB,CAAJ,EAA8BA,MAAM4E,cAAN;aACvB,IAAP;;;;;;QAOA,CAACjJ,MAAD,KACCiQ,QAAQiF,MAAR,CAAe7Q,KAAf,KACC4L,QAAQE,gBAAR,CAAyB9L,KAAzB,CADD,IAEC4L,QAAQI,eAAR,CAAwBhM,KAAxB,CAFD,IAGC4L,QAAQM,oBAAR,CAA6BlM,KAA7B,CAHD,IAIC4L,QAAQQ,mBAAR,CAA4BpM,KAA5B,CAJD,IAKC4L,QAAQU,oBAAR,CAA6BtM,KAA7B,CALD,IAMC4L,QAAQY,mBAAR,CAA4BxM,KAA5B,CAND,IAOC4L,QAAQkF,QAAR,CAAiB9Q,KAAjB,CAPD,IAQC4L,QAAQc,MAAR,CAAe1M,KAAf,CARD,IASC4L,QAAQC,YAAR,CAAqB7L,KAArB,CATD,IAUC4L,QAAQmF,oBAAR,CAA6B/Q,KAA7B,CAVD,IAWC4L,QAAQgB,MAAR,CAAe5M,KAAf,CAZF,CADF,EAcE;YACM4E,cAAN;;;YAGI,WAAN,EAAmB,EAAE5E,YAAF,EAAnB;;;;;;;;;;;WAWOgO,OAAT,CAAiBhO,KAAjB,EAAwBqI,MAAxB,EAAgC7Y,MAAhC,EAAwC;QAClCA,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;;UAGrBqR,cAAN;;YAEM,SAAN,EAAiB,EAAE5E,YAAF,EAAjB;;;;;;;;;;;WAWOsB,QAAT,CAAkBtB,KAAlB,EAAyBqI,MAAzB,EAAiC7Y,MAAjC,EAAyC;QACnCogB,SAAJ,EAAe,OAAO,IAAP;QACXL,WAAJ,EAAiB,OAAO,IAAP;QACb/f,OAAOT,KAAP,CAAawE,QAAjB,EAA2B,OAAO,IAAP;;;QAGrB8D,SAASsC,UAAUqG,MAAMc,MAAhB,CAAf;oBACgBzJ,OAAOxF,QAAP,CAAgBwP,aAAhC;;YAEM,UAAN,EAAkB,EAAErB,YAAF,EAAlB;;;;;;;;;SASK;gCAAA;kBAAA;sBAAA;sCAAA;0CAAA;kBAAA;gBAAA;wBAAA;4BAAA;0BAAA;4BAAA;0BAAA;4BAAA;kBAAA;oBAAA;oBAAA;wBAAA;oBAAA;;GAAP;;;AC9cF;;;;;;AAMA,SAASgR,IAAT,GAAgB;;ACQhB;;;;;;AAMA,IAAMpiB,UAAQC,MAAM,cAAN,CAAd;;;;;;;;IAQMoiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCA+EgB;WACbtR,GAAL,CAASuR,OAAT;;UAEQC,SAHU,GAGI,KAAKpiB,KAHT,CAGVoiB,SAHU;UAIV9I,MAJU,GAIC,KAAK1I,GAJN,CAIV0I,MAJU;;;UAMd8I,SAAJ,EAAe;YACT9I,MAAJ,EAAY;iBACH/P,KAAP;SADF,MAEO;eACAA,KAAL;;;;UAIA+P,MAAJ,EAAY;aACL2H,QAAL,CAAc3H,MAAd;;;;;;;;;;uCAQe+I,WAAW;WACvBzR,GAAL,CAASuR,OAAT;;iBAEsC,KAAKvR,GAHf;UAGpB0I,MAHoB,QAGpBA,MAHoB;UAGZgJ,QAHY,QAGZA,QAHY;UAGFH,OAHE,QAGFA,OAHE;;;;;cAQ1BG,WAAW,CAAX,IAAgBA,aAAaH,OAD/B,EAEE,mRAFF;;UAKI7I,MAAJ,EAAY;aACL2H,QAAL,CAAc3H,MAAd;;;;;;;;;;;;6BAUK;cACD,QAAN,EAAgB,IAAhB;UACMtZ,qBAAa,KAAKA,KAAlB,CAAN;UACMuiB,OAAO,KAAK7hB,KAAL,CAAW8hB,MAAX,CAAkB,cAAlB,EAAkCxiB,KAAlC,EAAyC,IAAzC,CAAb;aACOuiB,IAAP;;;;;;;;;;;2BASY;UACNE,UAAU,KAAKC,cAAL,CAAoB,KAAK1iB,KAAL,CAAWyiB,OAA/B,EAAwC,KAAKziB,KAAL,CAAWsB,MAAnD,CAAhB;aACOmhB,OAAP;;;;;;;;;;;2BASW;UACLnhB,SAAS,KAAKqhB,aAAL,CAAmB,KAAKF,OAAxB,CAAf;aACOnhB,MAAP;;;;;;;;;;;2BASU;UACJZ,QAAQ,KAAKkiB,YAAL,CAAkB,KAAKH,OAAvB,CAAd;aACO/hB,KAAP;;;;;;;;;;;2BASU;;;;UAKR,KAAK+hB,OAAL,KAAiB,KAAK7R,GAAL,CAAS6R,OAA1B,IACA,KAAKziB,KAAL,CAAWqB,KAAX,KAAqB,KAAKuP,GAAL,CAASvP,KAFhC,EAGE;eACO,KAAKuP,GAAL,CAASvP,KAAhB;;;UAGIA,QAAQ,KAAKwhB,YAAL,CAAkB,KAAKJ,OAAvB,EAAgC,KAAKziB,KAAL,CAAWqB,KAA3C,CAAd;aACOA,KAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAvLiBa,MAAMC;;;;;;AAArB+f,OAOG9f,YAAY;eACJG,MAAMsC,IADF;aAENtC,MAAMsC,IAFA;aAGNtC,MAAMpD,MAHA;YAIPoD,MAAM+Q,IAJC;eAKJ/Q,MAAMqC,GALF;WAMRrC,MAAMugB,KANE;YAOPvgB,MAAMsC,IAPC;QAQXtC,MAAMpD,MARK;UASToD,MAAM3C,MATG;cAUL2C,MAAMsC,IAVD;SAWVtC,MAAM3C,MAXI;YAYP2C,MAAMC,MAZC;SAaVH,WAAWhB,KAAX,CAAiBiB,UAbP;AAPf4f,OA6BGne,eAAe;aACT,KADS;eAEP,IAFO;YAGVke,IAHU;WAIX,EAJW;YAKV,KALU;UAMZ,EANY;cAOR,IAPQ;;;;;OAgBtB1B,QAAQ;OAQR3P,MAAM;YACI,IADJ;gBAEQ,KAFR;oBAGY,IAHZ;aAIK,IAJL;cAKM,CALN;aAMK,CANL;WAOG,IAPH;OAgBNC,WAAW9R,eAAe+B,MAAf,CAAsB,UAACgQ,GAAD,EAAMC,OAAN,EAAkB;QAC7CA,OAAJ,IAAe;aAAS,OAAKC,OAAL,CAAaD,OAAb,EAAsBE,KAAtB,CAAT;KAAf;WACOH,GAAP;GAFS,EAGR,EAHQ;;OA2HXwI,SAAS,YAAa;QAChB,OAAK1I,GAAL,CAASmS,UAAb,EAAyB;cAErB,KADF,EAEE,oNAFF;;;;;QAQIzJ,SAAS,OAAKjY,KAAL,CAAWiY,MAAX,EAAf;;QAEI;aACG1I,GAAL,CAASmS,UAAT,GAAsB,IAAtB;aACOpO,IAAP;KAFF,CAGE,OAAOwC,KAAP,EAAc;YACRA,KAAN;KAJF,SAKU;aACHvG,GAAL,CAASmS,UAAT,GAAsB,KAAtB;;;WAGG9B,QAAL,CAAc3H,MAAd;;;OAOF/H,OAAO,YAAM;WACN+H,MAAL,CAAY;aAAK0B,EAAEzJ,IAAF,EAAL;KAAZ;;;OAOFhI,QAAQ,YAAM;WACP+P,MAAL,CAAY;aAAK0B,EAAEzR,KAAF,EAAL;KAAZ;;;OASF0X,WAAW,kBAAU;;QAEf3H,OAAO0J,UAAP,CAAkB/gB,IAAlB,KAA2B,CAA/B,EAAkC;;;;YAI5B,UAAN,EAAkB,EAAEqX,cAAF,EAAlB;aACS,OAAK2J,aAAL,CAAmB,OAAKR,OAAxB,EAAiCnJ,MAAjC,EAAyCA,OAAO0J,UAAP,CAAkB/gB,IAA3D,CAAT;;;;;WAKK2O,GAAL,CAASvP,KAAT,GAAiBiY,OAAOjY,KAAxB;WACKuP,GAAL,CAAS6R,OAAT,GAAmB,OAAKA,OAAxB;;;WAGO,OAAK7R,GAAL,CAAS0I,MAAhB;WACO,OAAK1I,GAAL,CAASsS,cAAhB;;WAEKljB,KAAL,CAAWihB,QAAX,CAAoB3H,MAApB;;;OAUFtI,UAAU,UAACD,OAAD,EAAUE,KAAV,EAAoB;WACvBqI,MAAL,CAAY,kBAAU;aACf5Y,KAAL,CAAWyiB,GAAX,CAAepS,OAAf,EAAwBE,KAAxB,EAA+BqI,MAA/B;KADF;;;OAcF2J,gBAAgBG,WAAW,UAACX,OAAD,EAAUnJ,MAAV,EAAkBrX,IAAlB,EAA2B;QAC9CvB,QAAQ,OAAKkiB,YAAL,CAAkBH,OAAlB,CAAd;UACMU,GAAN,CAAU,UAAV,EAAsB7J,MAAtB;WACOA,MAAP;GAHc;OAoBhBoJ,iBAAiBU,WAAW,YAA+B;QAA9BX,OAA8B,uEAApB,EAAoB;QAAhBnhB,MAAgB,uEAAP,EAAO;;YACnD,gBAAN,EAAwB,EAAEmhB,gBAAF,EAAWnhB,cAAX,EAAxB;WACKsP,GAAL,CAAS0R,QAAT;;QAEMe,eAAe1C,cAArB;QACM2C,cAAclK,aAApB;QACMmK,eAAe,EAAEjiB,cAAF,EAArB;;+BAEWkiB,KAR8C;;UAUnDA,SAAQ,UAAZ,EAAwB;;;;UAIpBA,SAAQ,QAAZ,EAAsB;;;mBAGTA,KAAb,IAAqB,YAAa;;;eACzB,OAAKxjB,KAAL,CAAWwjB,KAAX,KAAoB,iBAAKxjB,KAAL,EAAWwjB,KAAX,0BAA3B;OADF;;;;;;;;4BATiBC,YAAnB,mIAAkC;YAAvBD,KAAuB;;0BAAvBA,KAAuB;;kCAMV;;;;;;;;;;;;;;;;;YAQhBH,YAAR,EAAsBE,YAAtB,2BAAuCd,OAAvC,IAAgDa,WAAhD;GAtBe;OAgCjBX,gBAAgBS,WAAW,mBAAW;YAC9B,eAAN,EAAuB,EAAEX,gBAAF,EAAvB;QACMnhB,SAASoiB,OAAOpO,MAAP,CAAc,EAAEmN,gBAAF,EAAd,CAAf;WACOnhB,MAAP;GAHc;OAahBshB,eAAeQ,WAAW,mBAAW;YAC7B,cAAN,EAAsB,EAAEX,gBAAF,EAAtB;QACM/hB,QAAQijB,MAAMrO,MAAN,CAAa,EAAEmN,gBAAF,EAAb,CAAd;WACO/hB,KAAP;GAHa;OAcfmiB,eAAeO,WAAW,UAACX,OAAD,EAAUphB,KAAV,EAAoB;YACtC,cAAN,EAAsB,EAAEohB,gBAAF,EAAWphB,YAAX,EAAtB;QACIiY,SAASjY,MAAMiY,MAAN,EAAb;aACS,OAAK2J,aAAL,CAAmBR,OAAnB,EAA4BnJ,MAA5B,EAAoCA,OAAO0J,UAAP,CAAkB/gB,IAAtD,CAAT;;;;WAIK2O,GAAL,CAAS0I,MAAT,GAAkBA,MAAlB;WACK1I,GAAL,CAASsS,cAAT,GAA0B5J,OAAO0J,UAAP,CAAkB/gB,IAA5C;;WAEOqX,OAAOjY,KAAd;GAVa;;;;;;;;uBAkBEtC,cAAnB,8HAAmC;QAAxBykB,IAAwB;;WAC1BphB,SAAP,CAAiBohB,IAAjB,IAAyBjhB,MAAM+Q,IAA/B;;;;;;;;;;;;;;;;;;;;;;;ACxXF,YAAe;gBAAA;8BAAA;4BAAA;4BAAA;oBAAA;sBAAA;8BAAA;oCAAA;oCAAA;0BAAA;;CAAf;;;;;"}